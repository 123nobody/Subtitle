[Script Info]
; Script generated by Aegisub 3.1.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None
Last Style Storage: Default
Aegisub Scroll Position: 0
Aegisub Active Line: 1
Aegisub Video Zoom Percent: 1.000000

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: 冬青黑体简体中文,冬青黑体简体中文 W3,20,&H00FFFFFF,&HF0000000,&H00000000,&H32000000,0,0,0,0,100,100,0,0,1,1,0,2,5,5,20,134

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:04.88,0:00:07.66,冬青黑体简体中文,,0,0,0,,斯坦福大学\N{\fs14}> Stanford University.
Dialogue: 0,0:00:11.56,0:00:21.13,冬青黑体简体中文,,0,0,0,,欢迎来到2013/14学年秋季CS193P课程第四讲\N{\fs14}> Welcome to lecture 4, then, of CS 193P for fall of academic year 2013/14.
Dialogue: 0,0:00:21.13,0:00:24.10,冬青黑体简体中文,,0,0,0,,今天的内容几乎都将是幻灯片\N{\fs14}Today I'm going to do pretty much all slides.
Dialogue: 0,0:00:24.10,0:00:28.31,冬青黑体简体中文,,0,0,0,,还有一点时间我们会简要看一个demo\N{\fs14}I do have one brief time when we'll stop and do a little demo.
Dialogue: 0,0:00:28.31,0:00:31.25,冬青黑体简体中文,,0,0,0,,然后下一讲开始\N{\fs14}And then at the beginning of next lecture,
Dialogue: 0,0:00:31.25,0:00:34.40,冬青黑体简体中文,,0,0,0,,我会讲一个demo 基本上演示了\N{\fs14}I'll be doing a demo that pretty much demonstrates the vast
Dialogue: 0,0:00:34.40,0:00:37.20,冬青黑体简体中文,,0,0,0,,这一讲在幻灯中讲的大多数内容\N{\fs14}majority of what I talk about in the slides today.
Dialogue: 0,0:00:37.20,0:00:39.29,冬青黑体简体中文,,0,0,0,,这将是这门课一贯的做法\N{\fs14}And remember, that's kind of how it's always going to go:
Dialogue: 0,0:00:39.29,0:00:42.96,冬青黑体简体中文,,0,0,0,,我先讲一些幻灯片 然后用demo进行演示\N{\fs14}I'll show it to you in slides, we'll talk about it, then I'll demo it to you.
Dialogue: 0,0:00:42.96,0:00:46.24,冬青黑体简体中文,,0,0,0,,因为看到demo比听老师一个劲在那讲\N{\fs14}Because when you see a demo, it all makes a lot more sense than if someone's just talking
Dialogue: 0,0:00:46.24,0:00:48.98,冬青黑体简体中文,,0,0,0,,API相关的抽象概念要容易理解得多\N{\fs14}in an abstract conceptually about an API.
Dialogue: 0,0:00:48.98,0:00:51.53,冬青黑体简体中文,,0,0,0,,然后作业通常是要你们做这个\N{\fs14}And then your homework is usually going to ask you to do this.
Dialogue: 0,0:00:51.53,0:00:54.53,冬青黑体简体中文,,0,0,0,,你们需要在课上注意我都讲了什么\N{\fs14}So it's, you know, you get a lot out of paying attention
Dialogue: 0,0:00:54.53,0:00:56.70,冬青黑体简体中文,,0,0,0,,因为这会为你们做作业提供很多提示\N{\fs14}in the lectures because I'm pretty much going to give you hints
Dialogue: 0,0:00:56.70,0:00:59.90,冬青黑体简体中文,,0,0,0,,因为这会为你们做作业提供很多提示\N{\fs14}and basically tell you a lot of how to do the homework --
Dialogue: 0,0:00:59.90,0:01:01.85,冬青黑体简体中文,,0,0,0,,至少在iOS这方面\N{\fs14}at least from the iOS side of it.
Dialogue: 0,0:01:01.85,0:01:06.26,冬青黑体简体中文,,0,0,0,,我还要求你们在意思考和设计这方面\N{\fs14}I'm still going to ask you to do the thinking side of it, the designing side of it.
Dialogue: 0,0:01:06.26,0:01:08.70,冬青黑体简体中文,,0,0,0,,今天我们将首先谈到\N{\fs14}So today we're going to start off by talking
Dialogue: 0,0:01:08.70,0:01:11.39,冬青黑体简体中文,,0,0,0,,Objective-C方面的各种知识\N{\fs14}about a little bit more miscellaneous Objective-C.
Dialogue: 0,0:01:11.39,0:01:13.90,冬青黑体简体中文,,0,0,0,,然后我会讲到Foundation框架\N{\fs14}And then I'm going to go into talking about Foundation,
Dialogue: 0,0:01:13.90,0:01:17.19,冬青黑体简体中文,,0,0,0,,也就是其中具有数组 字典等内容的框架\N{\fs14}which is this framework that has arrays, and dictionaries, and all that in it.
Dialogue: 0,0:01:17.19,0:01:20.74,冬青黑体简体中文,,0,0,0,,最后我们会离开Foundation这一主题\N{\fs14}And we'll start to transition out of Foundation at the end
Dialogue: 0,0:01:20.74,0:01:23.89,冬青黑体简体中文,,0,0,0,,并开始讨论字体 颜色等内容\N{\fs14}of that and start talking about things like fonts and colors,
Dialogue: 0,0:01:23.89,0:01:25.35,冬青黑体简体中文,,0,0,0,,这些显然不属于Foundation\N{\fs14}which are obviously not in Foundation
Dialogue: 0,0:01:25.35,0:01:28.59,冬青黑体简体中文,,0,0,0,,因为Foundation不是基于UI的\N{\fs14}because Foundation is really not a UI-based thing;
Dialogue: 0,0:01:28.59,0:01:32.80,冬青黑体简体中文,,0,0,0,,它是用于构建模型 控制器 视图的\N{\fs14}it's for building both your model, and your controller, and your view.
Dialogue: 0,0:01:32.80,0:01:36.36,冬青黑体简体中文,,0,0,0,,但它是用户界面层之下的一层\N{\fs14}But it's, you know, a layer below the user interface layer.
Dialogue: 0,0:01:36.36,0:01:38.09,冬青黑体简体中文,,0,0,0,,我们开始进入主题\N{\fs14}So let's dive right in.
Dialogue: 0,0:01:38.09,0:01:39.88,冬青黑体简体中文,,0,0,0,,我们先来看创建对象\N{\fs14}Let's talk about creating objects.
Dialogue: 0,0:01:39.88,0:01:42.42,冬青黑体简体中文,,0,0,0,,希望这些东西是显而易见的\N{\fs14}A few of these things are pretty obvious I hope, but I just want
Dialogue: 0,0:01:42.42,0:01:45.53,冬青黑体简体中文,,0,0,0,,这里我只是想把它们放到幻灯片中正式提一下\N{\fs14}to put them on slides so that you have them in writing here.
Dialogue: 0,0:01:45.53,0:01:48.25,冬青黑体简体中文,,0,0,0,,大多数时候 当我们在堆中创建对象时\N{\fs14}You know that most of the time when we create objects in the heap,
Dialogue: 0,0:01:48.25,0:01:50.63,冬青黑体简体中文,,0,0,0,,我们用的是alloc init 对吧\N{\fs14}we do it with this alloc init business, right?
Dialogue: 0,0:01:50.63,0:01:54.56,冬青黑体简体中文,,0,0,0,,有时init是[NSMutableArray alloc] init中的init\N{\fs14}So sometimes the init is just init like NSMutableArray alloc init,
Dialogue: 0,0:01:54.56,0:01:58.36,冬青黑体简体中文,,0,0,0,,有时 它更复杂 例如CardMatchingGame中的init\N{\fs14}and sometimes it's more complicated init like we had with our card matching game --
Dialogue: 0,0:01:58.36,0:02:00.16,冬青黑体简体中文,,0,0,0,,initWithCardCount usingDeck\N{\fs14}init with card count using deck --
Dialogue: 0,0:02:00.16,0:02:01.61,冬青黑体简体中文,,0,0,0,,你们需要熟悉这些\N{\fs14}so that you're used to that.
Dialogue: 0,0:02:01.61,0:02:03.94,冬青黑体简体中文,,0,0,0,,你们还见过这种在堆中创建对象的方式\N{\fs14}And you've also seen us create objects in the heap
Dialogue: 0,0:02:03.94,0:02:06.59,冬青黑体简体中文,,0,0,0,,使用类方法 例如stringWithFormat\N{\fs14}using class methods like string with format.
Dialogue: 0,0:02:06.59,0:02:08.41,冬青黑体简体中文,,0,0,0,,记得吧 我们用过NSString stringWithFormat\N{\fs14}Remember, we did NSString, string with format.
Dialogue: 0,0:02:08.41,0:02:09.63,冬青黑体简体中文,,0,0,0,,这是一个类方法\N{\fs14}And that's a class method, right?
Dialogue: 0,0:02:09.63,0:02:13.44,冬青黑体简体中文,,0,0,0,,因为它是开方括号 类名 然后类方法\N{\fs14}Because it's open square bracket, name of a class, and then class method.
Dialogue: 0,0:02:13.44,0:02:17.68,冬青黑体简体中文,,0,0,0,,这是两种你们见过的创建对象的不同方式\N{\fs14}So it gets kind of two different ways you've seen already to create objects.
Dialogue: 0,0:02:17.68,0:02:19.93,冬青黑体简体中文,,0,0,0,,有时 对于一些方法\N{\fs14}Sometimes for some methods,
Dialogue: 0,0:02:19.93,0:02:23.21,冬青黑体简体中文,,0,0,0,,同时有init和类方法\N{\fs14}there's both an init and a class method.
Dialogue: 0,0:02:23.21,0:02:25.05,冬青黑体简体中文,,0,0,0,,stringWithFormat就是一个例子\N{\fs14}So string with format is an example
Dialogue: 0,0:02:25.05,0:02:27.21,冬青黑体简体中文,,0,0,0,,这里有alloc initWithFormat\N{\fs14}that there's alloc init with format
Dialogue: 0,0:02:27.22,0:02:29.72,冬青黑体简体中文,,0,0,0,,还有NSString stringWithFormat\N{\fs14}and there's NSString, string with format.
Dialogue: 0,0:02:29.72,0:02:32.32,冬青黑体简体中文,,0,0,0,,它们的作用完全相同\N{\fs14}They do exactly the same thing.
Dialogue: 0,0:02:32.32,0:02:35.50,冬青黑体简体中文,,0,0,0,,两者都在这里 可以说是一些历史原因\N{\fs14}Both of them are there for kind of historical reasons.
Dialogue: 0,0:02:35.50,0:02:38.77,冬青黑体简体中文,,0,0,0,,在我们有这种自动引用计数之前\N{\fs14}Back before we had this automatic reference counting --
Dialogue: 0,0:02:38.77,0:02:40.77,冬青黑体简体中文,,0,0,0,,这种强弱之类的东西\N{\fs14}you know, the strong and weak thing --
Dialogue: 0,0:02:40.77,0:02:46.06,冬青黑体简体中文,,0,0,0,,你需要更加明确 何时引用事物\N{\fs14}you had to be much more explicit about things when you were going to reference them,
Dialogue: 0,0:02:46.06,0:02:49.73,冬青黑体简体中文,,0,0,0,,何时取消引用 何时将它们从堆中清除 等等\N{\fs14}and when they got dereferenced, and when you cleared them out of the heap, and all that stuff.
Dialogue: 0,0:02:49.73,0:02:53.10,冬青黑体简体中文,,0,0,0,,其中一种方式就是使用这些类方法\N{\fs14}And one of the ways that was done was using these class methods
Dialogue: 0,0:02:53.10,0:02:57.87,冬青黑体简体中文,,0,0,0,,来创建能够用特定方式释放的字符串\N{\fs14}to create the string in a way that it would get released in certain ways.
Dialogue: 0,0:02:57.87,0:02:59.67,冬青黑体简体中文,,0,0,0,,所有这些现在都不再重要\N{\fs14}So all of that doesn't matter anymore.
Dialogue: 0,0:02:59.67,0:03:02.17,冬青黑体简体中文,,0,0,0,,这样我们就同时有了这两者\N{\fs14}So now we're kind of stuck with having both of these things.
Dialogue: 0,0:03:02.17,0:03:05.41,冬青黑体简体中文,,0,0,0,,在我看来 苹果的iOS设计者们\N{\fs14}It seems to me that iOS, the designers at Apple --
Dialogue: 0,0:03:05.41,0:03:07.12,冬青黑体简体中文,,0,0,0,,顺便说下 我不为苹果工作\N{\fs14}I don't work at Apple, by the way.
Dialogue: 0,0:03:07.12,0:03:09.09,冬青黑体简体中文,,0,0,0,,有人问过我 我不在苹果工作\N{\fs14}Some people have asked me if I work at Apple; I don't work at Apple.
Dialogue: 0,0:03:09.09,0:03:11.87,冬青黑体简体中文,,0,0,0,,我和你们一样 是从外部去看iOS的\N{\fs14}So I'm just seeing iOS from the outside just like you are.
Dialogue: 0,0:03:11.87,0:03:15.51,冬青黑体简体中文,,0,0,0,,在我看来 iOS的人越来越偏向于alloc init\N{\fs14}It looks to me like iOS people are moving towards alloc init,
Dialogue: 0,0:03:15.51,0:03:19.77,冬青黑体简体中文,,0,0,0,,逐渐从类方法偏离\N{\fs14}okay, and kind of away from the class methods.
Dialogue: 0,0:03:19.77,0:03:22.58,冬青黑体简体中文,,0,0,0,,不过在特定环境下 我仍然会看到类方法\N{\fs14}Although I still see the class methods coming up in certain circumstances, too.
Dialogue: 0,0:03:22.58,0:03:24.55,冬青黑体简体中文,,0,0,0,,这方面也许存在某种考虑\N{\fs14}And there's probably some reasoning behind it.
Dialogue: 0,0:03:24.55,0:03:28.95,冬青黑体简体中文,,0,0,0,,我没看到过苹果官方说偏好哪一种\N{\fs14}I haven't seen it put in writing by Apple as to when they choose which,
Dialogue: 0,0:03:28.95,0:03:33.18,冬青黑体简体中文,,0,0,0,,不过这门课的过程中 你们随便用哪种都是安全的\N{\fs14}but you're certainly safe in this class until they start marketing some of these things
Dialogue: 0,0:03:33.18,0:03:37.09,冬青黑体简体中文,,0,0,0,,苹果应该不会在这么短的时间内决定废掉哪种\N{\fs14}as deprecated, like, don't use them anymore, to use either form.
Dialogue: 0,0:03:37.09,0:03:39.46,冬青黑体简体中文,,0,0,0,,我多数时候更偏爱alloc init\N{\fs14}I tend to try to go for the alloc inits most of the time,
Dialogue: 0,0:03:39.46,0:03:41.82,冬青黑体简体中文,,0,0,0,,除非没有alloc init能实现我的目的\N{\fs14}unless there isn't an alloc init that does what I want;
Dialogue: 0,0:03:41.83,0:03:43.58,冬青黑体简体中文,,0,0,0,,这时我就会用类方法\N{\fs14}then I'll use a class method.
Dialogue: 0,0:03:43.58,0:03:45.68,冬青黑体简体中文,,0,0,0,,不过还有其它方式可以创建对象\N{\fs14}But there's other ways to create objects.
Dialogue: 0,0:03:45.68,0:03:50.48,冬青黑体简体中文,,0,0,0,,你可以让另一个对象为你创建对象\N{\fs14}You can create objects by asking another object to create an object for you.
Dialogue: 0,0:03:50.48,0:03:52.96,冬青黑体简体中文,,0,0,0,,例如stringByAppendingString\N{\fs14}So that's like string by appending string.
Dialogue: 0,0:03:52.96,0:03:55.61,冬青黑体简体中文,,0,0,0,,这不是字符串的类方法 这是实例方法\N{\fs14}That's not a class method in string; that's an instance method.
Dialogue: 0,0:03:55.61,0:04:00.00,冬青黑体简体中文,,0,0,0,,你将它发送给一个字符串 你将它给第二个字符串\N{\fs14}You send it to another string, you give it a second string,
Dialogue: 0,0:04:00.00,0:04:03.39,冬青黑体简体中文,,0,0,0,,它会为你创建一个新字符串 因为字符串是不可变的\N{\fs14}and it will create a new string for you since strings are immutable.
Dialogue: 0,0:04:03.39,0:04:04.91,冬青黑体简体中文,,0,0,0,,NSString是不可变的\N{\fs14}NSString is immutable.
Dialogue: 0,0:04:04.91,0:04:06.40,冬青黑体简体中文,,0,0,0,,它会创建一个新字符串\N{\fs14}It creates a new string
Dialogue: 0,0:04:06.40,0:04:10.37,冬青黑体简体中文,,0,0,0,,这是将参数中的字符串加到原字符串后面\N{\fs14}that is the string you sent it to with the one you passed as an argument added on, right?
Dialogue: 0,0:04:10.37,0:04:13.01,冬青黑体简体中文,,0,0,0,,这就为你创建了一个新对象\N{\fs14}So there it's creating a new object for you.
Dialogue: 0,0:04:13.01,0:04:16.55,冬青黑体简体中文,,0,0,0,,一个很有趣的实例方法\N{\fs14}And a very interesting instance method
Dialogue: 0,0:04:16.55,0:04:19.77,冬青黑体简体中文,,0,0,0,,你可以让对象为你做的\N{\fs14}that you can ask an object to do for you
Dialogue: 0,0:04:19.77,0:04:22.22,冬青黑体简体中文,,0,0,0,,是mutableCopy(可变复制)\N{\fs14}is mutable copy.
Dialogue: 0,0:04:22.22,0:04:25.59,冬青黑体简体中文,,0,0,0,,mutableCopy会复制一个对象 但它是可变的\N{\fs14}So mutable copy makes a copy of an object but it's mutable.
Dialogue: 0,0:04:25.59,0:04:27.72,冬青黑体简体中文,,0,0,0,,例如将NSString发送给mutableCopy\N{\fs14}So if you had an NSString and you send it mutable copy,
Dialogue: 0,0:04:27.72,0:04:29.95,冬青黑体简体中文,,0,0,0,,你会得到NSMutableString\N{\fs14}you'll get back an NSMutableString.
Dialogue: 0,0:04:29.95,0:04:32.66,冬青黑体简体中文,,0,0,0,,或者将NSArray发送给mutableCopy\N{\fs14}Or if you have an NSArray and you send it a mutable copy,
Dialogue: 0,0:04:32.66,0:04:34.64,冬青黑体简体中文,,0,0,0,,你会得到一个NSMutableArray\N{\fs14}you'll get an NSMutableArray.
Dialogue: 0,0:04:34.64,0:04:39.38,冬青黑体简体中文,,0,0,0,,这是创建对象的另一种方式\N{\fs14}So that's another way that that happens that you're creating objects.
Dialogue: 0,0:04:39.38,0:04:43.43,冬青黑体简体中文,,0,0,0,,当然 并非所有返回对象的方法都会创建一个对象\N{\fs14}Of course, not all methods that return an object are creating an object
Dialogue: 0,0:04:43.44,0:04:46.40,冬青黑体简体中文,,0,0,0,,例如NSArray中的lastObject firstObject\N{\fs14}like we saw in NSArray -- last object, and first object,
Dialogue: 0,0:04:46.40,0:04:47.42,冬青黑体简体中文,,0,0,0,,以及objectAtIndex\N{\fs14}and object at index.
Dialogue: 0,0:04:47.42,0:04:48.97,冬青黑体简体中文,,0,0,0,,这些没有创建新对象\N{\fs14}Those aren't creating new objects;
Dialogue: 0,0:04:48.97,0:04:52.57,冬青黑体简体中文,,0,0,0,,它们只是给你指针指向数组中的这些对象\N{\fs14}they're just giving you pointers to the objects that are in those array.
Dialogue: 0,0:04:52.57,0:04:55.49,冬青黑体简体中文,,0,0,0,,这对你们而言应该很明显\N{\fs14}That should be completely obvious to you
Dialogue: 0,0:04:55.49,0:04:59.02,冬青黑体简体中文,,0,0,0,,不过我这里想明确一下 这些是指向对象的指针\N{\fs14}but I just want to make it clear, you know, these are pointers to objects.
Dialogue: 0,0:04:59.02,0:05:01.36,冬青黑体简体中文,,0,0,0,,你可以有多个指针\N{\fs14}And you're allowed to have multiple pointers.
Dialogue: 0,0:05:01.36,0:05:06.02,冬青黑体简体中文,,0,0,0,,这里是普通的指针被来回传递\N{\fs14}And this is normal pointers here being passed around.
Dialogue: 0,0:05:06.02,0:05:10.28,冬青黑体简体中文,,0,0,0,,除非方法中有copy这个单词\N{\fs14}So basically, unless a method has the word "copy"
Dialogue: 0,0:05:10.28,0:05:14.08,冬青黑体简体中文,,0,0,0,,否则当方法返回给你一个已经存在的对象时\N{\fs14}in it, then if it's returning to you an object that exists somewhere else,
Dialogue: 0,0:05:14.08,0:05:16.32,冬青黑体简体中文,,0,0,0,,它会返回指向那个对象的指针\N{\fs14}it's going to be returning a pointer to that object,
Dialogue: 0,0:05:16.32,0:05:18.17,冬青黑体简体中文,,0,0,0,,除非方法中有copy这个词\N{\fs14}okay, unless it has the word "copy" in it like
Dialogue: 0,0:05:18.17,0:05:21.02,冬青黑体简体中文,,0,0,0,,例如mutableCopy或copy\N{\fs14}"mutable copy" or "copy."
Dialogue: 0,0:05:21.02,0:05:24.22,冬青黑体简体中文,,0,0,0,,如果你要返回的对象并不存在\N{\fs14}And if the object that you're getting back doesn't exist
Dialogue: 0,0:05:24.22,0:05:27.56,冬青黑体简体中文,,0,0,0,,它就会为你创建新的对象\N{\fs14}somewhere, then it's going to make a new one for you.
Dialogue: 0,0:05:27.56,0:05:31.61,冬青黑体简体中文,,0,0,0,,好 这是创建对象 非常简单\N{\fs14}All right. That's it on creating objects. Pretty straightforward there.
Dialogue: 0,0:05:31.61,0:05:33.42,冬青黑体简体中文,,0,0,0,,nil 我已经讲过了\N{\fs14}Okay. Nil, I already talked about this,
Dialogue: 0,0:05:33.42,0:05:37.70,冬青黑体简体中文,,0,0,0,,我们可以通过为nil的指针发送消息\N{\fs14}that we can send messages through a pointer that is nil,
Dialogue: 0,0:05:37.70,0:05:39.89,冬青黑体简体中文,,0,0,0,,也就是说该指针不指向任何东西\N{\fs14}i.e. that pointer does not point to anything.
Dialogue: 0,0:05:39.89,0:05:41.93,冬青黑体简体中文,,0,0,0,,没有代码会被执行\N{\fs14}And no code gets executed.
Dialogue: 0,0:05:41.93,0:05:42.78,冬青黑体简体中文,,0,0,0,,如果我写\N{\fs14}So if I do this
Dialogue: 0,0:05:42.79,0:05:45.95,冬青黑体简体中文,,0,0,0,,int i = [obj methodWhichReturnsAnInt]\N{\fs14}init I equals obj method which returns an init,
Dialogue: 0,0:05:45.95,0:05:49.78,冬青黑体简体中文,,0,0,0,,没有代码执行到methodWhichReturnsAnInt\N{\fs14}no code gets executed to execute method which returns an init;
Dialogue: 0,0:05:49.79,0:05:50.81,冬青黑体简体中文,,0,0,0,,但是\N{\fs14}however,
Dialogue: 0,0:05:50.81,0:05:55.31,冬青黑体简体中文,,0,0,0,,发送方括号这些的消息会返回0\N{\fs14}that message sending square bracket thing will return zero.
Dialogue: 0,0:05:55.31,0:05:57.49,冬青黑体简体中文,,0,0,0,,知道这个很重要\N{\fs14}So that's important to know.
Dialogue: 0,0:05:57.49,0:05:59.64,冬青黑体简体中文,,0,0,0,,0也就是nil\N{\fs14}And zero is also what nil is.
Dialogue: 0,0:05:59.64,0:06:02.43,冬青黑体简体中文,,0,0,0,,如果你的方法返回一个对象\N{\fs14}So if you had a method that returned an object and you sent
Dialogue: 0,0:06:02.43,0:06:06.43,冬青黑体简体中文,,0,0,0,,你将那个消息发给nil 返回的也会是nil\N{\fs14}that message to nil, then you get back nil.
Dialogue: 0,0:06:06.43,0:06:09.26,冬青黑体简体中文,,0,0,0,,这可以用来帮助我们达到一些目的\N{\fs14}And we can use that, actually, to our advantage.
Dialogue: 0,0:06:09.26,0:06:15.00,冬青黑体简体中文,,0,0,0,,例如周一我们需要随机抽取纸牌 我们用了\N{\fs14}For example, in our thing we did on Monday, we did draw a random card, right?
Dialogue: 0,0:06:15.00,0:06:17.05,冬青黑体简体中文,,0,0,0,,self.deck drawRandomCard\N{\fs14}Self.deck draw random card.
Dialogue: 0,0:06:17.05,0:06:20.29,冬青黑体简体中文,,0,0,0,,如果牌堆里牌用完了 这会返回nil\N{\fs14}And that returned nil if the deck was out of cards.
Dialogue: 0,0:06:20.29,0:06:24.74,冬青黑体简体中文,,0,0,0,,如果牌堆本身是nil 这也会返回nil\N{\fs14}If the deck itself had been nil, that also would return nil.
Dialogue: 0,0:06:24.74,0:06:27.27,冬青黑体简体中文,,0,0,0,,这样我们就可以只写一个if\N{\fs14}So we can write one if that deals with the fact
Dialogue: 0,0:06:27.27,0:06:29.30,冬青黑体简体中文,,0,0,0,,来处理抽不到牌的情况\N{\fs14}that we can't get another card, whether it's
Dialogue: 0,0:06:29.30,0:06:32.90,冬青黑体简体中文,,0,0,0,,不管是因为牌堆空了 还是因为牌堆本就为nil\N{\fs14}because the deck is empty or because there is no deck because the deck is nil.
Dialogue: 0,0:06:32.90,0:06:35.36,冬青黑体简体中文,,0,0,0,,两种情况下 代码的执行都一样\N{\fs14}Either way, the code's going to look exactly the same.
Dialogue: 0,0:06:35.36,0:06:38.32,冬青黑体简体中文,,0,0,0,,你们会习惯这个的\N{\fs14}So you'll get used to that.
Dialogue: 0,0:06:38.32,0:06:39.93,冬青黑体简体中文,,0,0,0,,这显然同其它语言有所不同\N{\fs14}It's definitely different from other languages
Dialogue: 0,0:06:39.93,0:06:42.93,冬青黑体简体中文,,0,0,0,,其它语言中 你显然不希望将消息发送给nil\N{\fs14}where you're protecting against sending messages to nil.
Dialogue: 0,0:06:42.93,0:06:44.33,冬青黑体简体中文,,0,0,0,,但你们会习惯的\N{\fs14}But you'll get used to it.
Dialogue: 0,0:06:44.33,0:06:49.04,冬青黑体简体中文,,0,0,0,,你们确实需要小心 消息发送返回类型是struct的情况\N{\fs14}You do have to be careful. If the return type of a message send is a struct
Dialogue: 0,0:06:49.04,0:06:52.28,冬青黑体简体中文,,0,0,0,,因为你无法得到所有成员都设为0的struct\N{\fs14}because you don't get back a struct with all its members set to zero;
Dialogue: 0,0:06:52.28,0:06:54.27,冬青黑体简体中文,,0,0,0,,你得到的是一个未定义的struct\N{\fs14}you get back an undefined struct.
Dialogue: 0,0:06:54.27,0:06:56.45,冬青黑体简体中文,,0,0,0,,其中有什么是未定义的\N{\fs14}What's in there is undefined.
Dialogue: 0,0:06:56.45,0:06:59.29,冬青黑体简体中文,,0,0,0,,struct在栈上返回给你\N{\fs14}This struct is being returned to you on the stack.
Dialogue: 0,0:06:59.29,0:07:00.57,冬青黑体简体中文,,0,0,0,,你可能得到栈垃圾\N{\fs14}You might get stack garbage,
Dialogue: 0,0:07:00.57,0:07:02.52,冬青黑体简体中文,,0,0,0,,你可能得到0.struct 你无法知道\N{\fs14}you might get zero.struct, you just don't know.
Dialogue: 0,0:07:02.52,0:07:03.86,冬青黑体简体中文,,0,0,0,,你不能依赖它\N{\fs14}So you can't rely on it.
Dialogue: 0,0:07:03.86,0:07:06.57,冬青黑体简体中文,,0,0,0,,这里 代码中永远不要依赖这个\N{\fs14}So here you should never rely on that in your code.
Dialogue: 0,0:07:06.57,0:07:08.63,冬青黑体简体中文,,0,0,0,,如果你调用一个返回struct的方法\N{\fs14}If you call a method, it returns a struct,
Dialogue: 0,0:07:08.63,0:07:11.57,冬青黑体简体中文,,0,0,0,,你要检验 确保没有将它发送给nil\N{\fs14}you got to check to make sure you're not sending it to nil.
Dialogue: 0,0:07:13.77,0:07:15.68,冬青黑体简体中文,,0,0,0,,好 动态绑定\N{\fs14}All right. Dynamic binding.
Dialogue: 0,0:07:15.68,0:07:21.67,冬青黑体简体中文,,0,0,0,,Objective-C对方法分派和调用的处理\N{\fs14}So Objective-C handles the dispatching and calling of methods
Dialogue: 0,0:07:21.67,0:07:25.49,冬青黑体简体中文,,0,0,0,,不同于你们大多数人所熟悉的语言\N{\fs14}differently than languages that most of you are used to.
Dialogue: 0,0:07:25.49,0:07:27.41,冬青黑体简体中文,,0,0,0,,它所做的是动态绑定\N{\fs14}It does what's called "dynamic binding."
Dialogue: 0,0:07:27.41,0:07:32.33,冬青黑体简体中文,,0,0,0,,通过这张幻灯片的讲解 你们会知道动态绑定是什么\N{\fs14}And you'll see what dynamic binding is as we go through this slide.
Dialogue: 0,0:07:32.33,0:07:36.39,冬青黑体简体中文,,0,0,0,,Objective-C动态绑定很重要的一点在于\N{\fs14}But the important thing to understand about dynamic binding and about Objective-C is
Dialogue: 0,0:07:36.40,0:07:41.99,冬青黑体简体中文,,0,0,0,,Objective-C中有一个非常非常重要的类型叫id\N{\fs14}that there's a really, really important type in Objective-C called "ID," okay?
Dialogue: 0,0:07:41.99,0:07:46.15,冬青黑体简体中文,,0,0,0,,我们将它读作I-D 而不是id\N{\fs14}We call it "ID." We don't call it id by the way; ID we call it.
Dialogue: 0,0:07:46.15,0:07:49.88,冬青黑体简体中文,,0,0,0,,代码中我会说 id myObject\N{\fs14}So here in that line of code I would say that's ID my object.
Dialogue: 0,0:07:49.88,0:07:54.86,冬青黑体简体中文,,0,0,0,,这里声明了一个指针 我的对象 类型为id\N{\fs14}So I'm declaring a pointer, my object, which is a type ID.
Dialogue: 0,0:07:54.86,0:07:58.81,冬青黑体简体中文,,0,0,0,,id是一个指针\N{\fs14}So ID means pointer -- ID is a pointer,
Dialogue: 0,0:07:58.81,0:08:00.23,冬青黑体简体中文,,0,0,0,,所以不需要id\N{\fs14}so we don't use ID star;
Dialogue: 0,0:08:00.23,0:08:01.51,冬青黑体简体中文,,0,0,0,,id就是指针\N{\fs14}ID is a pointer --
Dialogue: 0,0:08:01.51,0:08:05.30,冬青黑体简体中文,,0,0,0,,它是一个指针 指向类未知的对象\N{\fs14}it means a pointer to an object where I don't know its class.
Dialogue: 0,0:08:05.30,0:08:08.06,冬青黑体简体中文,,0,0,0,,指向未知类型或未指定类型\N{\fs14}Of unknown type or unspecified type.
Dialogue: 0,0:08:08.06,0:08:09.88,冬青黑体简体中文,,0,0,0,,这是指向对象的指针\N{\fs14}So it's just a pointer to an object;
Dialogue: 0,0:08:09.88,0:08:13.00,冬青黑体简体中文,,0,0,0,,我对对象则一无所知\N{\fs14}I do not know anything about that object.
Dialogue: 0,0:08:13.00,0:08:16.97,冬青黑体简体中文,,0,0,0,,实际上 Objective-C中的所有指针都是id\N{\fs14}Really, all pointers in Objective-C are IDs
Dialogue: 0,0:08:16.97,0:08:20.64,冬青黑体简体中文,,0,0,0,,当你将消息发送给一个对象时\N{\fs14}in that the decision about what code to execute
Dialogue: 0,0:08:20.64,0:08:23.44,冬青黑体简体中文,,0,0,0,,关于执行什么代码的决定\N{\fs14}when you send a message to an object is not determined
Dialogue: 0,0:08:23.44,0:08:26.23,冬青黑体简体中文,,0,0,0,,直到运行时才会决定\N{\fs14}until runtime when you send that message.
Dialogue: 0,0:08:26.23,0:08:28.21,冬青黑体简体中文,,0,0,0,,当你发送一个消息时\N{\fs14}When you send a message,
Dialogue: 0,0:08:28.21,0:08:30.61,冬青黑体简体中文,,0,0,0,,一个函数会被调用\N{\fs14}it's essentially calling a function that's looking
Dialogue: 0,0:08:30.61,0:08:35.07,冬青黑体简体中文,,0,0,0,,查阅消息发送时 对应于所指向的那一特定类\N{\fs14}up the right code to execute for that particular class
Dialogue: 0,0:08:35.07,0:08:37.50,冬青黑体简体中文,,0,0,0,,所应执行的正确代码\N{\fs14}that you're pointing to at the time you send the message.
Dialogue: 0,0:08:37.50,0:08:41.09,冬青黑体简体中文,,0,0,0,,这被叫作动态或迟绑定\N{\fs14}That's called dynamic or late binding.
Dialogue: 0,0:08:41.09,0:08:46.81,冬青黑体简体中文,,0,0,0,,Objective-C中的所有消息发送都是这样做的\N{\fs14}And all message sends -- all of them in Objective-C -- are done this way.
Dialogue: 0,0:08:46.81,0:08:49.38,冬青黑体简体中文,,0,0,0,,这意味着什么呢\N{\fs14}Now, what does this mean?
Dialogue: 0,0:08:50.39,0:08:54.31,冬青黑体简体中文,,0,0,0,,这意味着… 先看这安全吗\N{\fs14}It means that -- well, is this safe, right?
Dialogue: 0,0:08:54.31,0:08:56.02,冬青黑体简体中文,,0,0,0,,因为你肯定会担心\N{\fs14}Because you're worried, I'm sure,
Dialogue: 0,0:08:56.02,0:08:59.24,冬青黑体简体中文,,0,0,0,,我将消息发送给一个对象 如果它不理解该怎么办\N{\fs14}"What if I send a message to an object and it doesn't understand it?"
Dialogue: 0,0:08:59.24,0:09:02.28,冬青黑体简体中文,,0,0,0,,没有机制能够阻止你这样做\N{\fs14}Okay. Well, nothing stops you from doing that.
Dialogue: 0,0:09:02.28,0:09:05.31,冬青黑体简体中文,,0,0,0,,不仅如此 如果你这样做 程序就会崩溃\N{\fs14}And not only that, if you do that, your program will crash.
Dialogue: 0,0:09:05.31,0:09:06.76,冬青黑体简体中文,,0,0,0,,这会引发异常\N{\fs14}It will raise an exception.
Dialogue: 0,0:09:06.76,0:09:08.80,冬青黑体简体中文,,0,0,0,,除非捕获异常 否则程序会崩溃\N{\fs14}Unless you catch the exception, it will crash.
Dialogue: 0,0:09:08.80,0:09:11.04,冬青黑体简体中文,,0,0,0,,你心里可能会想 哇\N{\fs14}And so you're probably feeling like, "Wow.
Dialogue: 0,0:09:11.04,0:09:13.57,冬青黑体简体中文,,0,0,0,,这些Objective-C程序肯定总在崩溃\N{\fs14}These Objective-C programs must be crashing all the time
Dialogue: 0,0:09:13.57,0:09:16.36,冬青黑体简体中文,,0,0,0,,因为一不小心就容易将消息发送给\N{\fs14}because you accidentally send a message to an object;
Dialogue: 0,0:09:16.36,0:09:18.13,冬青黑体简体中文,,0,0,0,,不理解消息的对象\N{\fs14}it doesn't understand that message."
Dialogue: 0,0:09:18.13,0:09:19.76,冬青黑体简体中文,,0,0,0,,但实际不是这样\N{\fs14}But actually, it doesn't happen.
Dialogue: 0,0:09:19.76,0:09:21.32,冬青黑体简体中文,,0,0,0,,为什么没有发生呢\N{\fs14}Okay. Why doesn't that happen?
Dialogue: 0,0:09:21.32,0:09:22.45,冬青黑体简体中文,,0,0,0,,原因有两点\N{\fs14}And there's really two reasons.
Dialogue: 0,0:09:22.45,0:09:25.15,冬青黑体简体中文,,0,0,0,,一是我们经常使用静态类型化\N{\fs14}One is we use static typing a lot.
Dialogue: 0,0:09:25.15,0:09:26.98,冬青黑体简体中文,,0,0,0,,我们不经常使用id\N{\fs14}We don't use ID that much.
Dialogue: 0,0:09:26.98,0:09:29.02,冬青黑体简体中文,,0,0,0,,我们使用NSString *这些\N{\fs14}We use, like, NSString star.
Dialogue: 0,0:09:29.02,0:09:32.05,冬青黑体简体中文,,0,0,0,,NSString *完全等同于使用id\N{\fs14}Now, NSString star is exactly the same as using ID,
Dialogue: 0,0:09:32.05,0:09:36.47,冬青黑体简体中文,,0,0,0,,只是编译器在编译你的代码时\N{\fs14}except that the compiler, while it's compiling your code,
Dialogue: 0,0:09:36.47,0:09:40.70,冬青黑体简体中文,,0,0,0,,知道你至少是意图让该指针指向一个字符串\N{\fs14}knows that you at least intend that that pointer points to a string.
Dialogue: 0,0:09:40.70,0:09:44.33,冬青黑体简体中文,,0,0,0,,如果你尝试发送非字符串消息给该指针 它会抱怨\N{\fs14}So if you tried to send a nonstring message to that pointer, it's going to complain.
Dialogue: 0,0:09:44.33,0:09:46.02,冬青黑体简体中文,,0,0,0,,它会给你警告\N{\fs14}It's going to, you know, give you warnings.
Dialogue: 0,0:09:46.02,0:09:50.45,冬青黑体简体中文,,0,0,0,,所以在编译Objective-C程序时 你应确保没有警告\N{\fs14}And so when you compile your Objective-C programs they should always have no warnings,
Dialogue: 0,0:09:50.45,0:09:53.72,冬青黑体简体中文,,0,0,0,,这样你就能够确保没有这种问题了\N{\fs14}and then you can be pretty sure that you're not going to have this problem
Dialogue: 0,0:09:53.72,0:09:55.25,冬青黑体简体中文,,0,0,0,,没有在运行时将消息\N{\fs14}where you send a message to an object at runtime
Dialogue: 0,0:09:55.25,0:09:58.24,冬青黑体简体中文,,0,0,0,,发送给一个不理解它的对象 从而导致崩溃\N{\fs14}and it doesn't understand it and it crashes.
Dialogue: 0,0:09:58.26,0:10:00.74,冬青黑体简体中文,,0,0,0,,这是第一种方式\N{\fs14}So that's the number one way.
Dialogue: 0,0:10:00.74,0:10:02.93,冬青黑体简体中文,,0,0,0,,我要讲的第二种方式是\N{\fs14}And the second way I'm going to talk about
Dialogue: 0,0:10:02.93,0:10:05.80,冬青黑体简体中文,,0,0,0,,很多时候 在运行时我们都会检验\N{\fs14}is that a lot of times we will check at runtime.
Dialogue: 0,0:10:05.80,0:10:08.80,冬青黑体简体中文,,0,0,0,,我们会看这个id指针\N{\fs14}We'll look at that ID pointer.
Dialogue: 0,0:10:08.80,0:10:12.28,冬青黑体简体中文,,0,0,0,,在发送之前 我们会检验它是否能够正确作出反应\N{\fs14}And we will check and see if it responds to something before we send it.
Dialogue: 0,0:10:13.45,0:10:15.35,冬青黑体简体中文,,0,0,0,,你们知道静态类型化\N{\fs14}So you know about static typing,
Dialogue: 0,0:10:15.36,0:10:18.11,冬青黑体简体中文,,0,0,0,,也就是NSString *s = @"x"\N{\fs14}that's the NSString star S equals at sign X.
Dialogue: 0,0:10:18.11,0:10:20.26,冬青黑体简体中文,,0,0,0,,这是非常安全 非常好的做法\N{\fs14}This is really safe, really good,
Dialogue: 0,0:10:20.26,0:10:21.85,冬青黑体简体中文,,0,0,0,,任何糟糕的事情都不会发生在这里\N{\fs14}nothing bad's going to happen here
Dialogue: 0,0:10:21.86,0:10:25.19,冬青黑体简体中文,,0,0,0,,因为编译器在编译时很好地知道你想要什么\N{\fs14}because the compiler at compile time has a pretty good idea what you intend
Dialogue: 0,0:10:25.19,0:10:26.64,冬青黑体简体中文,,0,0,0,,如果不是 它会警告你\N{\fs14}and it will warn you if not.
Dialogue: 0,0:10:26.64,0:10:33.48,冬青黑体简体中文,,0,0,0,,但是 编译器没有绑定这时执行的代码\N{\fs14}However, the compiler is not doing the binding between what codes executes at this time;
Dialogue: 0,0:10:33.49,0:10:35.96,冬青黑体简体中文,,0,0,0,,它只是警告你 这是语法上的甜头\N{\fs14}it's just warning you. It's syntactic sugar.
Dialogue: 0,0:10:35.96,0:10:38.82,冬青黑体简体中文,,0,0,0,,这种语法 它能看到并警告你\N{\fs14}It's syntax that it can look at to warn you,
Dialogue: 0,0:10:38.82,0:10:41.06,冬青黑体简体中文,,0,0,0,,但这里没有任何强制作用\N{\fs14}but it's not actually enforcing anything here.
Dialogue: 0,0:10:41.06,0:10:45.43,冬青黑体简体中文,,0,0,0,,用id obj =s也完全合法\N{\fs14}It's perfectly legal to say ID obj equals S,
Dialogue: 0,0:10:45.43,0:10:47.45,冬青黑体简体中文,,0,0,0,,s也就是之前的s\N{\fs14}where S is the line before.
Dialogue: 0,0:10:47.45,0:10:49.66,冬青黑体简体中文,,0,0,0,,这里就连警告都不会产生了\N{\fs14}And that will not even generate a warning.
Dialogue: 0,0:10:49.66,0:10:52.47,冬青黑体简体中文,,0,0,0,,因为id obj是指向任何对象的指针\N{\fs14}Because ID obj is a pointer to any kind of object;
Dialogue: 0,0:10:52.47,0:10:54.52,冬青黑体简体中文,,0,0,0,,s是指向任何对象的指针\N{\fs14}S is a pointer to any kind of object.
Dialogue: 0,0:10:54.52,0:10:57.12,冬青黑体简体中文,,0,0,0,,根据前一行 它是一个指向字符串的指针\N{\fs14}It's a pointer to a string, according to the previous line.
Dialogue: 0,0:10:57.12,0:11:00.56,冬青黑体简体中文,,0,0,0,,但由于两者都是指向对象的指针 这完全合法\N{\fs14}But since those are both pointers to objects, that's perfectly legal.
Dialogue: 0,0:11:00.56,0:11:01.93,冬青黑体简体中文,,0,0,0,,编译器不会警告你\N{\fs14}Compiler will not warn you.
Dialogue: 0,0:11:01.93,0:11:04.58,冬青黑体简体中文,,0,0,0,,这一行代码就有些危险了\N{\fs14}This is a little bit of a dangerous line of code, right?
Dialogue: 0,0:11:04.58,0:11:08.80,冬青黑体简体中文,,0,0,0,,因为之前 s是类型化良好的变量\N{\fs14}Because you just went from having S -- this nice variable that's typed
Dialogue: 0,0:11:08.80,0:11:11.37,冬青黑体简体中文,,0,0,0,,如果你做了不正确的事 编译器会告诉你\N{\fs14}and the compiler can warn you if you do the wrong thing --
Dialogue: 0,0:11:11.37,0:11:14.00,冬青黑体简体中文,,0,0,0,,而obj是没有类型化的指针\N{\fs14}to having an obj, which is this untyped pointer
Dialogue: 0,0:11:14.00,0:11:17.21,冬青黑体简体中文,,0,0,0,,不管发送什么消息 编译器都不会警告你\N{\fs14}where you can send any message you want and the compiler's not going to warn you.
Dialogue: 0,0:11:17.21,0:11:21.93,冬青黑体简体中文,,0,0,0,,你还可以这样 NSArray *a = obj\N{\fs14}You can also do this NSArray star A equals obj.
Dialogue: 0,0:11:21.93,0:11:26.48,冬青黑体简体中文,,0,0,0,,这时你就让NSArray变量指向了一个字符串\N{\fs14}Okay. Now you have NSArray variable that points to a string.
Dialogue: 0,0:11:26.48,0:11:29.77,冬青黑体简体中文,,0,0,0,,这很可能会导致问题\N{\fs14}Now, that's extremely likely to cause a problem.
Dialogue: 0,0:11:29.77,0:11:31.39,冬青黑体简体中文,,0,0,0,,这也是合法的\N{\fs14}This is also legal
Dialogue: 0,0:11:31.39,0:11:34.58,冬青黑体简体中文,,0,0,0,,因为NSArray *a是一个指向对象的指针\N{\fs14}because NSArray star A is a pointer to an object;
Dialogue: 0,0:11:34.58,0:11:38.93,冬青黑体简体中文,,0,0,0,,obj也是一个指向对象的指针 所以这样赋值是允许的\N{\fs14}obj is a pointer to an object, so it allows this assignment.
Dialogue: 0,0:11:38.93,0:11:40.84,冬青黑体简体中文,,0,0,0,,非常危险 而且明显错误\N{\fs14}Very dangerous. Obviously wrong.
Dialogue: 0,0:11:40.84,0:11:42.86,冬青黑体简体中文,,0,0,0,,这三行代码放到一起 显然是错误的\N{\fs14}If these three lines of code are there, that's clearly wrong.
Dialogue: 0,0:11:42.86,0:11:45.82,冬青黑体简体中文,,0,0,0,,你不应当让NSArray指向NSString\N{\fs14}You would not want to have an NSArray pointing to an NSString.
Dialogue: 0,0:11:45.82,0:11:49.04,冬青黑体简体中文,,0,0,0,,id在这方面可能会非常危险\N{\fs14}So ID can be dangerous in this way.
Dialogue: 0,0:11:49.04,0:11:54.11,冬青黑体简体中文,,0,0,0,,实际上 我们在原来写的代码中也默默地做过这个\N{\fs14}And in fact, in the code that we've written we already did this kind of silently.
Dialogue: 0,0:11:54.11,0:11:56.76,冬青黑体简体中文,,0,0,0,,在PlayingCard的match中\N{\fs14}Remember that in match, playing card's match
Dialogue: 0,0:11:56.76,0:11:58.65,冬青黑体简体中文,,0,0,0,,我们有一行代码是\N{\fs14}we put a line in there that said, "Playing
Dialogue: 0,0:11:58.65,0:12:01.99,冬青黑体简体中文,,0,0,0,,PlayingCard *otherCard = [otherCards firstObject]\N{\fs14}card star other car equals other card's first object."
Dialogue: 0,0:12:01.99,0:12:02.90,冬青黑体简体中文,,0,0,0,,记得这个吗\N{\fs14}Remember that?
Dialogue: 0,0:12:02.90,0:12:06.82,冬青黑体简体中文,,0,0,0,,NSArray中的firstObject方法返回一个id\N{\fs14}Well, the method first object in an NSArray returns an ID.
Dialogue: 0,0:12:06.84,0:12:09.04,冬青黑体简体中文,,0,0,0,,你可以去查说明文档\N{\fs14}If you go look it up in the documentation,
Dialogue: 0,0:12:09.04,0:12:12.01,冬青黑体简体中文,,0,0,0,,其返回类型 括号id\N{\fs14}look at its return type -- parenthesis ID.
Dialogue: 0,0:12:12.01,0:12:15.59,冬青黑体简体中文,,0,0,0,,所以 我们将一个PlayingCard赋值给一个id\N{\fs14}So we just assigned a playing card to an ID.
Dialogue: 0,0:12:15.59,0:12:18.92,冬青黑体简体中文,,0,0,0,,所以 从数组中得到的对象最好是PlayingCard\N{\fs14}So that object that came out of that array better be a playing card
Dialogue: 0,0:12:18.92,0:12:20.46,冬青黑体简体中文,,0,0,0,,否则运行时就会崩溃\N{\fs14}or we're going to crash at runtime.
Dialogue: 0,0:12:20.47,0:12:22.29,冬青黑体简体中文,,0,0,0,,这堂课晚些时候\N{\fs14}And a little later in this lecture I'm going
Dialogue: 0,0:12:22.29,0:12:27.87,冬青黑体简体中文,,0,0,0,,我会讲到 如何保护代码 确保这种情况下不会崩溃\N{\fs14}to show you how we can protect our code to make sure that we don't crash in this case.
Dialogue: 0,0:12:27.87,0:12:31.80,冬青黑体简体中文,,0,0,0,,大家都明白为什么说这里有点危险了吗\N{\fs14}Does everyone see why this is a little dangerous?
Dialogue: 0,0:12:32.87,0:12:35.09,冬青黑体简体中文,,0,0,0,,这方面有问题吗\N{\fs14}Questions about that?
Dialogue: 0,0:12:35.09,0:12:37.64,冬青黑体简体中文,,0,0,0,,好 提醒一下 绝对不要用id\N{\fs14}Okay. And a reminder: Never use ID star.
Dialogue: 0,0:12:37.64,0:12:39.87,冬青黑体简体中文,,0,0,0,,id *没有意义 因为id就是指针\N{\fs14}ID star makes no sense because ID is a pointer.
Dialogue: 0,0:12:39.87,0:12:41.94,冬青黑体简体中文,,0,0,0,,id *将是指向指针的指针\N{\fs14}So ID star would be a pointer to a pointer.
Dialogue: 0,0:12:41.94,0:12:44.58,冬青黑体简体中文,,0,0,0,,我们在Objective-C中不会这样做\N{\fs14}We don't do that in Objective-C, okay,
Dialogue: 0,0:12:44.58,0:12:47.63,冬青黑体简体中文,,0,0,0,,特别是指向id的指针\N{\fs14}especially a pointer to an ID [inaudible].
Dialogue: 0,0:12:47.63,0:12:51.08,冬青黑体简体中文,,0,0,0,,为了总结上述内容 我将展示这个小小的例子\N{\fs14}All right. So to summarize all this I'm going to show you this example.
Dialogue: 0,0:12:51.08,0:12:53.44,冬青黑体简体中文,,0,0,0,,我有两个类 一个Vehicle(交通工具)类\N{\fs14}I've got two classes: I got a vehicle class,
Dialogue: 0,0:12:53.45,0:12:56.05,冬青黑体简体中文,,0,0,0,,它有一个方法move(运动) 交通工具可以运动\N{\fs14}which has what method move -- you can move the vehicle around --
Dialogue: 0,0:12:56.05,0:12:58.56,冬青黑体简体中文,,0,0,0,,然后有Ship(船)类 它是一种交通工具\N{\fs14}and I got a ship which is a vehicle,
Dialogue: 0,0:12:58.56,0:12:59.68,冬青黑体简体中文,,0,0,0,,继承自Vehicle\N{\fs14}inherits from vehicle,
Dialogue: 0,0:12:59.68,0:13:01.08,冬青黑体简体中文,,0,0,0,,它只有一个方法 shoot(射击)\N{\fs14}and it's only got one method, shoot.
Dialogue: 0,0:13:01.08,0:13:02.92,冬青黑体简体中文,,0,0,0,,这条船可以射击别的船\N{\fs14}So this ship can shoot other ships.
Dialogue: 0,0:13:02.92,0:13:05.13,冬青黑体简体中文,,0,0,0,,它也能运动 因为它是交通工具\N{\fs14}And they can also move because they're vehicles.
Dialogue: 0,0:13:05.13,0:13:09.70,冬青黑体简体中文,,0,0,0,,如果我声明一个局部变量 一条船s\N{\fs14}So if I declare a local variable ship, ship S,
Dialogue: 0,0:13:09.70,0:13:12.96,冬青黑体简体中文,,0,0,0,,类型是Ship * 我用alloc init分配初始化一条船\N{\fs14}which is a ship star, and I allocate init a ship,
Dialogue: 0,0:13:12.96,0:13:16.45,冬青黑体简体中文,,0,0,0,,我可以说s shoot或s move 都能行\N{\fs14}I can say "S shoot" or "S move" -- works fine, right?
Dialogue: 0,0:13:16.45,0:13:19.92,冬青黑体简体中文,,0,0,0,,因为Ship实现了shoot 继承了move\N{\fs14}Because ships implement shoot and they inherit move.
Dialogue: 0,0:13:19.92,0:13:22.01,冬青黑体简体中文,,0,0,0,,所以大家都相安无事\N{\fs14}So everybody's totally happy here.
Dialogue: 0,0:13:22.01,0:13:27.44,冬青黑体简体中文,,0,0,0,,我还可以写 Vehicle *v = s 这完全合法\N{\fs14}I can also do vehicle star V equals S. That's perfectly legal
Dialogue: 0,0:13:27.44,0:13:31.03,冬青黑体简体中文,,0,0,0,,因为v是一个交通工具 s也是一个交通工具\N{\fs14}because V is a vehicle and S is a vehicle
Dialogue: 0,0:13:31.03,0:13:33.73,冬青黑体简体中文,,0,0,0,,因为它从船中继承了交通工具的性质\N{\fs14}because it inherits its vehicle-ness from ship.
Dialogue: 0,0:13:33.73,0:13:36.60,冬青黑体简体中文,,0,0,0,,这有点像deck = [[PlayingCardDeck alloc] init]\N{\fs14}Okay. This is like deck equals playing card deck alloc init --
Dialogue: 0,0:13:36.60,0:13:39.72,冬青黑体简体中文,,0,0,0,,这是程序运行中完全合法的对象\N{\fs14}perfectly legal object to run in your programming, right?
Dialogue: 0,0:13:39.72,0:13:43.68,冬青黑体简体中文,,0,0,0,,下面我们尝试说 v shoot\N{\fs14}Okay. But now let's try to say V shoot.
Dialogue: 0,0:13:43.68,0:13:45.70,冬青黑体简体中文,,0,0,0,,这里会发生什么\N{\fs14}Now, what's going to happen here?
Dialogue: 0,0:13:45.70,0:13:48.46,冬青黑体简体中文,,0,0,0,,在编译时 你会得到警告\N{\fs14}All right. At compile time you're going to get a warning
Dialogue: 0,0:13:48.46,0:13:51.55,冬青黑体简体中文,,0,0,0,,因为交通工具没有实现shoot\N{\fs14}because vehicles do not implement shoot;
Dialogue: 0,0:13:51.56,0:13:53.82,冬青黑体简体中文,,0,0,0,,船有 但交通工具没有\N{\fs14}ships do but not vehicles.
Dialogue: 0,0:13:53.83,0:13:56.36,冬青黑体简体中文,,0,0,0,,明白这里为什么会有警告了吗\N{\fs14}So do you see why this is going to give you a warning?
Dialogue: 0,0:13:56.36,0:13:58.97,冬青黑体简体中文,,0,0,0,,运行时呢\N{\fs14}What about at runtime?
Dialogue: 0,0:13:58.97,0:14:01.13,冬青黑体简体中文,,0,0,0,,这段代码不会崩溃\N{\fs14}This code will not crash
Dialogue: 0,0:14:01.13,0:14:03.93,冬青黑体简体中文,,0,0,0,,因为我们知道v实际上是一条船\N{\fs14}because we know that V actually is a ship.
Dialogue: 0,0:14:03.93,0:14:06.33,冬青黑体简体中文,,0,0,0,,所以这在运行时会运行得很好\N{\fs14}So this will work fine at runtime.
Dialogue: 0,0:14:06.33,0:14:08.36,冬青黑体简体中文,,0,0,0,,明白了吗\N{\fs14}Okay? See that?
Dialogue: 0,0:14:08.36,0:14:14.56,冬青黑体简体中文,,0,0,0,,这种情况下 编译时出现警告 到运行时运行得很好\N{\fs14}So this is where you get a warning at compile time; runs fine at runtime.
Dialogue: 0,0:14:14.56,0:14:19.29,冬青黑体简体中文,,0,0,0,,这种情况呢 我声明一个obj\N{\fs14}Now, what about this case where I declare an obj, okay,
Dialogue: 0,0:14:19.29,0:14:21.14,冬青黑体简体中文,,0,0,0,,它可以是任何东西\N{\fs14}and it can be anything we want.
Dialogue: 0,0:14:21.14,0:14:25.99,冬青黑体简体中文,,0,0,0,,设法对它alloc init 然后写代码obj shoot\N{\fs14}Alloc init it somehow and you say "obj shoot," okay?
Dialogue: 0,0:14:25.99,0:14:27.80,冬青黑体简体中文,,0,0,0,,不管obj是什么\N{\fs14}No matter what obj is --
Dialogue: 0,0:14:27.80,0:14:29.67,冬青黑体简体中文,,0,0,0,,我故意没有讲清楚obj是什么\N{\fs14}and I intentionally didn't tell you what obj
Dialogue: 0,0:14:29.67,0:14:31.35,冬青黑体简体中文,,0,0,0,,因为不管obj是什么\N{\fs14}is because it doesn't matter what obj is.
Dialogue: 0,0:14:31.35,0:14:33.35,冬青黑体简体中文,,0,0,0,,编译器在这里都不会警告你\N{\fs14}The compiler is not going to warn you here.
Dialogue: 0,0:14:33.35,0:14:35.52,冬青黑体简体中文,,0,0,0,,任何时候将消息发送给obj\N{\fs14}Anytime you send a message to obj,
Dialogue: 0,0:14:35.52,0:14:39.22,冬青黑体简体中文,,0,0,0,,只要消息存在 编译器都不会警告你\N{\fs14}as long as that message exists somewhere, the compiler will not warn you.
Dialogue: 0,0:14:39.22,0:14:44.74,冬青黑体简体中文,,0,0,0,,运行时 obj不是船或其它能对shoot作出反应的对象\N{\fs14}At runtime, if obj is not a ship or some other object that responds to shoot,
Dialogue: 0,0:14:44.74,0:14:46.48,冬青黑体简体中文,,0,0,0,,程序就会崩溃\N{\fs14}it will crash.
Dialogue: 0,0:14:46.48,0:14:47.19,冬青黑体简体中文,,0,0,0,,有问题\N{\fs14}Question?
Dialogue: 0,0:14:47.19,0:14:50.07,冬青黑体简体中文,,0,0,0,,学生：id在这方面很特殊吗\N{\fs14}> Is ID special in that way?
Dialogue: 0,0:14:50.07,0:14:51.32,冬青黑体简体中文,,0,0,0,,老师：哪方面\N{\fs14}> In what way?
Dialogue: 0,0:14:51.32,0:14:55.52,冬青黑体简体中文,,0,0,0,,学生：因为似乎在这种情况下\N{\fs14}> Because it seems like it's a similar case where
Dialogue: 0,0:14:55.52,0:15:00.70,冬青黑体简体中文,,0,0,0,,不管你怎么对obj赋值 它是指向对象的指针\N{\fs14}whatever you've assigned obj is a pointer to an object
Dialogue: 0,0:15:00.70,0:15:05.51,冬青黑体简体中文,,0,0,0,,但它可能 也可能不具有这种方法\N{\fs14}but it may or may not have this method.
Dialogue: 0,0:15:05.51,0:15:07.94,冬青黑体简体中文,,0,0,0,,老师：问题是 id在这方面很特殊吗\N{\fs14}> Well, so the question is: Is ID special in that way?
Dialogue: 0,0:15:07.94,0:15:11.33,冬青黑体简体中文,,0,0,0,,你是说 id特殊在我可以发送任何消息给它\N{\fs14}You mean is ID special in that I can send it any message I want
Dialogue: 0,0:15:11.33,0:15:12.83,冬青黑体简体中文,,0,0,0,,而编译器不会警告我\N{\fs14}and the compiler won't warn me?
Dialogue: 0,0:15:12.83,0:15:15.09,冬青黑体简体中文,,0,0,0,,对 这就是id的语义\N{\fs14}Yes. Because that's kind of the semantics of ID.
Dialogue: 0,0:15:15.09,0:15:18.07,冬青黑体简体中文,,0,0,0,,id是一个指针 指向类未知的对象\N{\fs14}ID means a pointer to some object I don't know the class of.
Dialogue: 0,0:15:18.07,0:15:20.85,冬青黑体简体中文,,0,0,0,,所以编译器没法给你警告\N{\fs14}So there's no way for the compiler to give you a warning.
Dialogue: 0,0:15:20.85,0:15:23.76,冬青黑体简体中文,,0,0,0,,它只会假设 有人会对shoot作出反应\N{\fs14}So it just assumes "Okay, somebody responds to shoot.
Dialogue: 0,0:15:23.76,0:15:26.46,冬青黑体简体中文,,0,0,0,,也许是这个 我不会警告你\N{\fs14}So it might be this one, so I'm not going to warn you."
Dialogue: 0,0:15:26.46,0:15:28.49,冬青黑体简体中文,,0,0,0,,确实 id在这方面很特殊\N{\fs14}So yeah, ID is special in that way, I guess.
Dialogue: 0,0:15:28.49,0:15:34.00,冬青黑体简体中文,,0,0,0,,这就是我们不像这样单纯使用id的原因\N{\fs14}That's why we don't want to use ID unadorned like this.
Dialogue: 0,0:15:34.00,0:15:37.24,冬青黑体简体中文,,0,0,0,,如果我说 obj 某不存在的方法名\N{\fs14}If I'd say obj some method name that doesn't exist,
Dialogue: 0,0:15:37.24,0:15:38.92,冬青黑体简体中文,,0,0,0,,它确实会警告我\N{\fs14}then it will warn me.
Dialogue: 0,0:15:38.92,0:15:41.85,冬青黑体简体中文,,0,0,0,,如果任何地方都找不到这个方法\N{\fs14}So if it can't find that method anywhere,
Dialogue: 0,0:15:41.85,0:15:44.89,冬青黑体简体中文,,0,0,0,,编译器所知道的任何对象都没实现这种方法\N{\fs14}no object that the compiler's ever heard of implements that method,
Dialogue: 0,0:15:44.89,0:15:46.24,冬青黑体简体中文,,0,0,0,,那它肯定会警告你\N{\fs14}then it will at least warn you.
Dialogue: 0,0:15:46.24,0:15:49.04,冬青黑体简体中文,,0,0,0,,因为这时你很有可能是敲错了 犯了语法错误\N{\fs14}Because then it's likely you had a syntax error. You mistyped it.
Dialogue: 0,0:15:49.04,0:15:51.56,冬青黑体简体中文,,0,0,0,,这时编译器就会帮你\N{\fs14}And so the compiler is going to help you there.
Dialogue: 0,0:15:53.24,0:15:56.50,冬青黑体简体中文,,0,0,0,,假设我有一个NSString *hello\N{\fs14}So let's say I had an NSString star hello.
Dialogue: 0,0:15:56.50,0:15:58.94,冬青黑体简体中文,,0,0,0,,我让它等于@"hello"\N{\fs14}And I'm going to make it equal to at sign hello.
Dialogue: 0,0:15:58.94,0:16:00.72,冬青黑体简体中文,,0,0,0,,如果我说 hello shoot\N{\fs14}If I say hello shoot,
Dialogue: 0,0:16:00.72,0:16:02.89,冬青黑体简体中文,,0,0,0,,编译器显然会警告我说\N{\fs14}the compiler's obviously going to warn me and say,
Dialogue: 0,0:16:02.89,0:16:04.79,冬青黑体简体中文,,0,0,0,,字符串不会对shoot作出反应\N{\fs14}"Strings don't respond to shoot."
Dialogue: 0,0:16:04.79,0:16:07.96,冬青黑体简体中文,,0,0,0,,而运行时 这会崩溃\N{\fs14}And at runtime this would crash
Dialogue: 0,0:16:07.96,0:16:10.03,冬青黑体简体中文,,0,0,0,,因为字符串不会对shoot作出反应\N{\fs14}because, of course, strings don't respond to shoot.
Dialogue: 0,0:16:10.03,0:16:14.35,冬青黑体简体中文,,0,0,0,,这很好 我们就希望情况是这样\N{\fs14}Okay, so this is all good. This is the way we want things.
Dialogue: 0,0:16:14.35,0:16:17.77,冬青黑体简体中文,,0,0,0,,如果这样做呢 Ship *helloShip =\N{\fs14}What if I did this, ship star hello ship equals
Dialogue: 0,0:16:17.78,0:16:18.96,冬青黑体简体中文,,0,0,0,,类型转换\N{\fs14}cast --
Dialogue: 0,0:16:18.96,0:16:21.35,冬青黑体简体中文,,0,0,0,,大家都知道类型转换吧\N{\fs14}okay, everyone knows about casting, right,
Dialogue: 0,0:16:21.35,0:16:26.37,冬青黑体简体中文,,0,0,0,,所有语言几乎都有类型转换\N{\fs14}all languages have casting pretty much; well, most languages that you know --
Dialogue: 0,0:16:26.37,0:16:29.10,冬青黑体简体中文,,0,0,0,,(Ship *)hello\N{\fs14}parenthesis ship star hello.
Dialogue: 0,0:16:29.10,0:16:32.53,冬青黑体简体中文,,0,0,0,,这完全是合法的 编译器也不会警告我\N{\fs14}This is perfectly legal. And the compiler will not warn me.
Dialogue: 0,0:16:32.53,0:16:37.25,冬青黑体简体中文,,0,0,0,,我这里是将字符串放到了Ship *指针中\N{\fs14}So I've now taken a string and put it in a ship star pointer.
Dialogue: 0,0:16:37.25,0:16:40.74,冬青黑体简体中文,,0,0,0,,这时编译器会认为helloShip是一条船\N{\fs14}And the compiler now thinks that that hello ship is a ship.
Dialogue: 0,0:16:40.74,0:16:44.24,冬青黑体简体中文,,0,0,0,,它只会在看到船没有的方法时才会抱怨\N{\fs14}And so it's only going to complain if you do things to it that don't look like ship,
Dialogue: 0,0:16:44.24,0:16:48.36,冬青黑体简体中文,,0,0,0,,虽然这里我们知道 这里是一个字符串\N{\fs14}even though we know we know that that is a string.
Dialogue: 0,0:16:48.36,0:16:51.16,冬青黑体简体中文,,0,0,0,,所以说 类型转换极度危险\N{\fs14}Okay. So casting can be super dangerous,
Dialogue: 0,0:16:51.16,0:16:53.14,冬青黑体简体中文,,0,0,0,,就像所有语言中一样\N{\fs14}just like in any language casting can be dangerous.
Dialogue: 0,0:16:53.14,0:16:54.46,冬青黑体简体中文,,0,0,0,,这里也很危险\N{\fs14}It can be dangerous here.
Dialogue: 0,0:16:54.46,0:16:56.72,冬青黑体简体中文,,0,0,0,,但我们有时会进行类型转换\N{\fs14}But we do do cast sometimes.
Dialogue: 0,0:16:56.72,0:16:58.14,冬青黑体简体中文,,0,0,0,,我们使用类型转换的时候\N{\fs14}And the times we cast are the
Dialogue: 0,0:16:58.15,0:17:01.56,冬青黑体简体中文,,0,0,0,,也就是我们使用id并加以保护的时候\N{\fs14}same kind of times we use ID, which is protected times.
Dialogue: 0,0:17:01.56,0:17:05.15,冬青黑体简体中文,,0,0,0,,下一张幻灯片中我会讲到这种保护\N{\fs14}I'm going talk about that protection on the next slide.
Dialogue: 0,0:17:05.15,0:17:09.26,冬青黑体简体中文,,0,0,0,,如果我们之后说 helloShip shoot\N{\fs14}So if we then said hello ship shoot, okay,
Dialogue: 0,0:17:09.26,0:17:12.79,冬青黑体简体中文,,0,0,0,,这不会造成编译错误\N{\fs14}that would not generate a compiling error
Dialogue: 0,0:17:12.79,0:17:14.96,冬青黑体简体中文,,0,0,0,,因为helloShip是一个Ship\N{\fs14}because hello ship is a ship star;
Dialogue: 0,0:17:14.96,0:17:16.63,冬青黑体简体中文,,0,0,0,,但它在运行时会崩溃\N{\fs14}however, it would crash at runtime
Dialogue: 0,0:17:16.63,0:17:19.27,冬青黑体简体中文,,0,0,0,,因为字符串不会对shoot作出反应\N{\fs14}because strings don't respond to shoot.
Dialogue: 0,0:17:19.27,0:17:20.53,冬青黑体简体中文,,0,0,0,,都明白了吗\N{\fs14}Everybody cool?
Dialogue: 0,0:17:20.53,0:17:21.45,冬青黑体简体中文,,0,0,0,,请讲\N{\fs14}Yeah?
Dialogue: 0,0:17:24.85,0:17:30.04,冬青黑体简体中文,,0,0,0,,类型转换什么都没做 只是把编译器糊弄了\N{\fs14}Okay, the typecasting really doesn't do anything; that is just tricking the compiler.
Dialogue: 0,0:17:30.04,0:17:33.70,冬青黑体简体中文,,0,0,0,,它其实没有执行任何代码\N{\fs14}That's not even executing really any code per se.
Dialogue: 0,0:17:33.70,0:17:37.19,冬青黑体简体中文,,0,0,0,,当你发送shoot时 它会尝试分派那个shoot\N{\fs14}It's when you send the shoot, it tries to dispatch that shoot
Dialogue: 0,0:17:37.19,0:17:39.64,冬青黑体简体中文,,0,0,0,,到那个helloShip变量\N{\fs14}to that variable, that hello ship variable.
Dialogue: 0,0:17:39.64,0:17:42.73,冬青黑体简体中文,,0,0,0,,结果这玩意是字符串 于是崩溃掉\N{\fs14}The thing turns out to be a string, and it crashes right there.
Dialogue: 0,0:17:44.57,0:17:48.70,冬青黑体简体中文,,0,0,0,,你还可以这样做 (id)hello shoot\N{\fs14}You can also do this: ID hello shoot.
Dialogue: 0,0:17:48.70,0:17:51.29,冬青黑体简体中文,,0,0,0,,hello是NSString\N{\fs14}So hello is the NSString star,
Dialogue: 0,0:17:51.29,0:17:54.13,冬青黑体简体中文,,0,0,0,,我将它转化为id 并将它发送给shoot\N{\fs14}and I casted it to ID and sent it shoot.
Dialogue: 0,0:17:54.13,0:17:56.29,冬青黑体简体中文,,0,0,0,,这也会抑制所有警告信息\N{\fs14}And that will suppress all warnings as well
Dialogue: 0,0:17:56.29,0:17:58.90,冬青黑体简体中文,,0,0,0,,因为我将shoot发送给一个id\N{\fs14}because now I'm sending shoot to an ID.
Dialogue: 0,0:17:58.90,0:18:01.51,冬青黑体简体中文,,0,0,0,,我只是想说 一行之内就能类型转换\N{\fs14}And I just want to show you here that you can cast it right in line;
Dialogue: 0,0:18:01.51,0:18:03.35,冬青黑体简体中文,,0,0,0,,无需创建新变量\N{\fs14}you don't have to create another variable.
Dialogue: 0,0:18:03.35,0:18:06.01,冬青黑体简体中文,,0,0,0,,在一行内进行类型转换 会骗过编译器\N{\fs14}If you cast it right in line, you fake out the compiler.
Dialogue: 0,0:18:06.01,0:18:07.73,冬青黑体简体中文,,0,0,0,,我们不希望骗过编译器\N{\fs14}Now, we don't want to be faking out the compiler.
Dialogue: 0,0:18:07.73,0:18:09.99,冬青黑体简体中文,,0,0,0,,编译器是我们的朋友 它能帮我们找bug\N{\fs14}Compiler is our friend. It helps us find bugs.
Dialogue: 0,0:18:09.99,0:18:12.35,冬青黑体简体中文,,0,0,0,,但这些都能够做到\N{\fs14}But this all can be done.
Dialogue: 0,0:18:12.35,0:18:14.79,冬青黑体简体中文,,0,0,0,,这里讲这些东西\N{\fs14}Mostly I put this up here to see the difference
Dialogue: 0,0:18:14.79,0:18:18.03,冬青黑体简体中文,,0,0,0,,我只是想讲清楚什么时候编译器能捕捉到\N{\fs14}between the compiler catching something and it crashing at runtime,
Dialogue: 0,0:18:18.03,0:18:21.22,冬青黑体简体中文,,0,0,0,,以及什么时候会在运行时崩溃\N{\fs14}okay, and when it does which.
Dialogue: 0,0:18:21.22,0:18:25.93,冬青黑体简体中文,,0,0,0,,好 我们什么时候会用到这种危险得荒唐的id呢\N{\fs14}All right. So when would we ever use this ridiculously dangerous thing of ID?
Dialogue: 0,0:18:25.93,0:18:28.54,冬青黑体简体中文,,0,0,0,,之前其实有人问过 NSArray中\N{\fs14}Well, someone asked earlier, "Can I have an NSArray
Dialogue: 0,0:18:28.54,0:18:30.34,冬青黑体简体中文,,0,0,0,,能否有不同种类的事物\N{\fs14}that has different kinds of things in it --
Dialogue: 0,0:18:30.34,0:18:32.92,冬青黑体简体中文,,0,0,0,,一些字符串 一些数字 一些别的\N{\fs14}some strings, some numbers, something else?"
Dialogue: 0,0:18:32.92,0:18:33.70,冬青黑体简体中文,,0,0,0,,当然可以\N{\fs14}Absolutely you can.
Dialogue: 0,0:18:33.70,0:18:36.94,冬青黑体简体中文,,0,0,0,,而且很多时候 你确实想要这样做\N{\fs14}And there's plenty of times when you absolutely want that.
Dialogue: 0,0:18:36.94,0:18:38.11,冬青黑体简体中文,,0,0,0,,这是很好的\N{\fs14}So it's great for that.
Dialogue: 0,0:18:38.11,0:18:41.23,冬青黑体简体中文,,0,0,0,,Java等其它语言 会让你告诉编译器\N{\fs14}Now, other language like Java lets you actually tell the
Dialogue: 0,0:18:41.23,0:18:44.18,冬青黑体简体中文,,0,0,0,,这个数组中有字符串\N{\fs14}compiler that this array has strings in it
Dialogue: 0,0:18:44.18,0:18:46.27,冬青黑体简体中文,,0,0,0,,让编译器在你取出对象时\N{\fs14}so that the compiler, when you pull objects out,
Dialogue: 0,0:18:46.27,0:18:48.96,冬青黑体简体中文,,0,0,0,,知道有什么类型 然后它来帮你\N{\fs14}it knows what type they are and it can kind of help you out.
Dialogue: 0,0:18:48.96,0:18:50.06,冬青黑体简体中文,,0,0,0,,Objective-C不是这样\N{\fs14}Objective-C doesn't have that.
Dialogue: 0,0:18:50.06,0:18:52.68,冬青黑体简体中文,,0,0,0,,编译器不会帮你处理数组内容\N{\fs14}So the compiler cannot help you with contents array.
Dialogue: 0,0:18:52.68,0:18:54.27,冬青黑体简体中文,,0,0,0,,这是你的责任\N{\fs14}So it's kind of your responsibility.
Dialogue: 0,0:18:54.27,0:18:56.42,冬青黑体简体中文,,0,0,0,,我会讲怎么处理这个的\N{\fs14}I'm going to show you how we deal with that.
Dialogue: 0,0:18:56.42,0:18:58.67,冬青黑体简体中文,,0,0,0,,第二点是 记得MVC的内容吗\N{\fs14}The second one is -- remember the MVC talk?
Dialogue: 0,0:18:58.67,0:19:03.57,冬青黑体简体中文,,0,0,0,,我讲了这种盲的结构化通信\N{\fs14}I talked about all this blind structured communication, right, this blind communication.
Dialogue: 0,0:19:03.57,0:19:05.41,冬青黑体简体中文,,0,0,0,,要有这种盲通信\N{\fs14}Well, to have blind communication you got
Dialogue: 0,0:19:05.41,0:19:08.74,冬青黑体简体中文,,0,0,0,,你需要有指针指向类型未知的对象\N{\fs14}to have pointers to objects of types you don't know.
Dialogue: 0,0:19:08.74,0:19:12.75,冬青黑体简体中文,,0,0,0,,视图要将目标动作这些发送给\N{\fs14}There's no way that the view can send the target action
Dialogue: 0,0:19:12.75,0:19:15.86,冬青黑体简体中文,,0,0,0,,不知道是什么类的控制器\N{\fs14}thing to the controller without knowing the class of the controller,
Dialogue: 0,0:19:15.87,0:19:18.05,冬青黑体简体中文,,0,0,0,,视图就必须有某种指针\N{\fs14}unless the view can have some kind of pointer
Dialogue: 0,0:19:18.05,0:19:20.60,冬青黑体简体中文,,0,0,0,,指向它不知道类型的控制器\N{\fs14}to a controller that it doesn't know the type of.
Dialogue: 0,0:19:20.60,0:19:24.12,冬青黑体简体中文,,0,0,0,,这是id的一大用途\N{\fs14}And that's big use of ID.
Dialogue: 0,0:19:24.12,0:19:27.41,冬青黑体简体中文,,0,0,0,,但是 我们需要保护我们自己\N{\fs14}However, we need to protect ourselves,
Dialogue: 0,0:19:27.41,0:19:30.04,冬青黑体简体中文,,0,0,0,,id方面 我们有两大方法来保护自己\N{\fs14}and there's two big ways that we protect ourselves against IDs.
Dialogue: 0,0:19:30.04,0:19:31.33,冬青黑体简体中文,,0,0,0,,一是内省\N{\fs14}One is introspection,
Dialogue: 0,0:19:31.33,0:19:33.36,冬青黑体简体中文,,0,0,0,,过几张幻灯片我就会讲到\N{\fs14}which I'm going to talk about in the next few slides,
Dialogue: 0,0:19:33.37,0:19:37.89,冬青黑体简体中文,,0,0,0,,也就是我们可以在运行时问一个id 你是什么类的\N{\fs14}which is we can ask an ID at runtime, "What class are you?"
Dialogue: 0,0:19:37.89,0:19:40.01,冬青黑体简体中文,,0,0,0,,或你对什么方法作出反应\N{\fs14}or "What methods do you respond to?"
Dialogue: 0,0:19:40.03,0:19:41.79,冬青黑体简体中文,,0,0,0,,这是一种很棒的保护方式\N{\fs14}So that's a great way to protect ourselves.
Dialogue: 0,0:19:41.79,0:19:44.08,冬青黑体简体中文,,0,0,0,,另一种方式叫作协议\N{\fs14}And then another way is called "protocols."
Dialogue: 0,0:19:44.08,0:19:49.03,冬青黑体简体中文,,0,0,0,,协议是在id后使用尖括号来表示\N{\fs14}And protocols is a way using little angle brackets after an ID to say,
Dialogue: 0,0:19:49.03,0:19:52.68,冬青黑体简体中文,,0,0,0,,这是一个id 一个指针 指向的对象我不知道类是什么\N{\fs14}"This is an ID, a pointer to some class I don't know what it is,
Dialogue: 0,0:19:52.68,0:19:55.16,冬青黑体简体中文,,0,0,0,,但它要能对尖括号中定义的这一组方法作出反应\N{\fs14}but it responds to this set of methods that I'm going to
Dialogue: 0,0:19:55.16,0:19:57.66,冬青黑体简体中文,,0,0,0,,但它要能对尖括号中定义的这一组方法作出反应\N{\fs14}define with this little angle bracket thing
Dialogue: 0,0:19:57.66,0:19:58.90,冬青黑体简体中文,,0,0,0,,如UIScrollViewDelegate\N{\fs14}like UI scroll view delegate."
Dialogue: 0,0:19:58.90,0:20:01.76,冬青黑体简体中文,,0,0,0,,这就是我们进行委托和数据源这些的方式\N{\fs14}And that's how we do the delegation and data source thing.
Dialogue: 0,0:20:01.76,0:20:05.33,冬青黑体简体中文,,0,0,0,,今天我们不会过多讲到协议 因为这里不大需要\N{\fs14}So we're not going to talk about protocols today because you don't quite need them.
Dialogue: 0,0:20:05.35,0:20:07.68,冬青黑体简体中文,,0,0,0,,我们也许会在下周或下下周讲到它\N{\fs14}We'll probably talk about them next week or the week after.
Dialogue: 0,0:20:07.68,0:20:10.22,冬青黑体简体中文,,0,0,0,,这是我们在id上保护自己的另一方式\N{\fs14}But that's another way we protect ourselves against ID
Dialogue: 0,0:20:10.22,0:20:13.76,冬青黑体简体中文,,0,0,0,,id后跟尖括号实际上介于纯id和静态类型之间\N{\fs14}by having like -- an ID with the angle brackets is kind of in
Dialogue: 0,0:20:13.76,0:20:17.80,冬青黑体简体中文,,0,0,0,,id后跟尖括号实际上介于纯id和静态类型化之间\N{\fs14}between pure ID and static typing. It's kind of in the middle, right?
Dialogue: 0,0:20:17.80,0:20:19.62,冬青黑体简体中文,,0,0,0,,这里静态类型化的不是类型\N{\fs14}Instead of static typing the type,
Dialogue: 0,0:20:19.62,0:20:22.91,冬青黑体简体中文,,0,0,0,,而是事物能够对其作出反应的消息\N{\fs14}we're just static typing the messages that the thing can respond to.
Dialogue: 0,0:20:22.91,0:20:25.73,冬青黑体简体中文,,0,0,0,,就安全而言 它可以说介于中间\N{\fs14}So it's kind of in the middle in terms of safety.
Dialogue: 0,0:20:26.70,0:20:29.30,冬青黑体简体中文,,0,0,0,,好 我们再来讲内省\N{\fs14}So let's talk about introspection, though.
Dialogue: 0,0:20:29.30,0:20:33.90,冬青黑体简体中文,,0,0,0,,NSObject中有一些内省方法\N{\fs14}There's a few introspection methods in NSObject.
Dialogue: 0,0:20:33.90,0:20:35.69,冬青黑体简体中文,,0,0,0,,这里我要讲三个\N{\fs14}I'm going to talk about three of them here.
Dialogue: 0,0:20:35.69,0:20:37.44,冬青黑体简体中文,,0,0,0,,isKindOfClass isMemberOfClass\N{\fs14}Is kind of class, is member of class,
Dialogue: 0,0:20:37.44,0:20:38.99,冬青黑体简体中文,,0,0,0,,以及respondsToSelector\N{\fs14}and responds to selector.
Dialogue: 0,0:20:38.99,0:20:41.14,冬青黑体简体中文,,0,0,0,,isKindOfClass及isMemberOfClass\N{\fs14}So is kind of class and is member of class
Dialogue: 0,0:20:41.14,0:20:42.90,冬青黑体简体中文,,0,0,0,,让你能够问一个NSObject\N{\fs14}lets you ask an NSObject
Dialogue: 0,0:20:42.90,0:20:45.16,冬青黑体简体中文,,0,0,0,,或者任何继承自NSObject的对象\N{\fs14}or anything that inherits from NSObject,
Dialogue: 0,0:20:45.16,0:20:47.07,冬青黑体简体中文,,0,0,0,,你属于这一系列类吗\N{\fs14}"Are you of this kind of class?
Dialogue: 0,0:20:47.07,0:20:48.83,冬青黑体简体中文,,0,0,0,,或者isMemberOfClass是说\N{\fs14}Or is member of class means,
Dialogue: 0,0:20:48.83,0:20:51.33,冬青黑体简体中文,,0,0,0,,你实际是这个类吗\N{\fs14}"Are you actually this class?"
Dialogue: 0,0:20:51.33,0:20:55.04,冬青黑体简体中文,,0,0,0,,不是这个类及它的子类 而是只包含这个类\N{\fs14}Not this class or something that inherits from it, but actually this actual class.
Dialogue: 0,0:20:55.04,0:21:00.46,冬青黑体简体中文,,0,0,0,,respondsToSelector说的则是 id指向的这一对象\N{\fs14}And then response to selector says, "Does this object that this ID points to,
Dialogue: 0,0:21:00.46,0:21:03.77,冬青黑体简体中文,,0,0,0,,是否对某一特定方法作出反应\N{\fs14}does it respond to a certain method?"
Dialogue: 0,0:21:03.77,0:21:09.67,冬青黑体简体中文,,0,0,0,,很不幸 这些方法的参数显得很不牢靠\N{\fs14}So the arguments unfortunately to these methods are really kind of wonky.
Dialogue: 0,0:21:09.67,0:21:12.46,冬青黑体简体中文,,0,0,0,,这些你们使用的时候照做即可\N{\fs14}And just you're going to have to take my word for it on these ones
Dialogue: 0,0:21:12.46,0:21:17.13,冬青黑体简体中文,,0,0,0,,因为等下我要用来解释这个的句子里\N{\fs14}because when I spit out the sentence in a second here that describes what the argument is,
Dialogue: 0,0:21:17.13,0:21:19.27,冬青黑体简体中文,,0,0,0,,会使用四次class(类)这个词\N{\fs14}I'm going to use the word "class" four times
Dialogue: 0,0:21:19.27,0:21:21.01,冬青黑体简体中文,,0,0,0,,每次都表示不同事物\N{\fs14}and it's going to mean four different things.
Dialogue: 0,0:21:21.01,0:21:24.47,冬青黑体简体中文,,0,0,0,,isKindOfClass的参数\N{\fs14}So the argument is kind of class,
Dialogue: 0,0:21:24.47,0:21:30.13,冬青黑体简体中文,,0,0,0,,是通过将类方法class发送到某一个类来得到\N{\fs14}you get by sending the class method class to the class,
Dialogue: 0,0:21:30.13,0:21:32.62,冬青黑体简体中文,,0,0,0,,这会给你一个大写C开头的Class\N{\fs14}which will give you a capital C Class,
Dialogue: 0,0:21:32.62,0:21:36.17,冬青黑体简体中文,,0,0,0,,这就是isKindOfClass的参数\N{\fs14}which is the argument to the is kind of class method.
Dialogue: 0,0:21:37.51,0:21:39.54,冬青黑体简体中文,,0,0,0,,这里有一个方法class\N{\fs14}So there's this method class.
Dialogue: 0,0:21:39.54,0:21:41.36,冬青黑体简体中文,,0,0,0,,在这里 NSString class\N{\fs14}You see it there, NSString class.
Dialogue: 0,0:21:41.36,0:21:45.51,冬青黑体简体中文,,0,0,0,,它是一个NSString的类方法 返回Class\N{\fs14}It's a class method on NSString returns a capital C Class.
Dialogue: 0,0:21:45.51,0:21:47.66,冬青黑体简体中文,,0,0,0,,这是isKindOfClass的参数\N{\fs14}And that's the thing that's the argument is kind of class.
Dialogue: 0,0:21:47.66,0:21:50.15,冬青黑体简体中文,,0,0,0,,它总是这样的形式 [obj isKindOfClass:\N{\fs14}It's always of this form, obj is kind of class,
Dialogue: 0,0:21:50.15,0:21:54.30,冬青黑体简体中文,,0,0,0,,[你要考虑的类 class]]\N{\fs14}open spare bracket, the class you want, class, close square bracket, closed square bracket.
Dialogue: 0,0:21:54.30,0:21:56.95,冬青黑体简体中文,,0,0,0,,它总是这样 照做就行了\N{\fs14}So it always looks like this. So just do it.
Dialogue: 0,0:21:56.95,0:22:00.25,冬青黑体简体中文,,0,0,0,,如果你不能理解句子中包含四个class的解释\N{\fs14}If you didn't understand my four-class sentence,
Dialogue: 0,0:22:00.25,0:22:03.38,冬青黑体简体中文,,0,0,0,,别管它 照做就行了\N{\fs14}just do it just like this.
Dialogue: 0,0:22:03.38,0:22:07.45,冬青黑体简体中文,,0,0,0,,发现对象属于这一系列类后 就可以进行类型转换了\N{\fs14}Once I see that an object kind of a class, then I might want to cast it.
Dialogue: 0,0:22:07.45,0:22:11.04,冬青黑体简体中文,,0,0,0,,注意这里我将obj转换为NSString *类型\N{\fs14}You see here I'm casting obj to be an NSString star there
Dialogue: 0,0:22:11.04,0:22:13.09,冬青黑体简体中文,,0,0,0,,因为我知道这时 它是NSString\N{\fs14}because I know at that point it's an NSString star.
Dialogue: 0,0:22:13.09,0:22:15.12,冬青黑体简体中文,,0,0,0,,所以这时愚弄编译器没有关系\N{\fs14}So it's okay to fool the compiler,
Dialogue: 0,0:22:15.12,0:22:19.52,冬青黑体简体中文,,0,0,0,,或者说 我是通过这样在教编译器更多关于obj的知识\N{\fs14}or really I'm teaching the compiler a little bit more about what obj is by doing that.
Dialogue: 0,0:22:19.52,0:22:20.75,冬青黑体简体中文,,0,0,0,,并非真的愚弄它\N{\fs14}Not really tricking it.
Dialogue: 0,0:22:20.77,0:22:23.26,冬青黑体简体中文,,0,0,0,,这样做是完全安全的 因为我知道obj\N{\fs14}And it's perfectly safe to do that because I know that obj
Dialogue: 0,0:22:23.26,0:22:26.34,冬青黑体简体中文,,0,0,0,,在运行时是这样的类\N{\fs14}at runtime is that kind of class.
Dialogue: 0,0:22:26.34,0:22:28.90,冬青黑体简体中文,,0,0,0,,这方面有问题吗 请讲\N{\fs14}Questions about that? Yeah?
Dialogue: 0,0:22:31.71,0:22:36.35,冬青黑体简体中文,,0,0,0,,问题是 实例方法class会怎样 我可以说\N{\fs14}Okay, the question is: What does the instance method class -- so I can say, you know,
Dialogue: 0,0:22:36.35,0:22:42.11,冬青黑体简体中文,,0,0,0,,想象一个例子 例如我们用过的deck\N{\fs14}trying to think of an example where we use that, like deck.
Dialogue: 0,0:22:42.11,0:22:45.34,冬青黑体简体中文,,0,0,0,,我可以说deck class\N{\fs14}I might say deck class, for example.
Dialogue: 0,0:22:45.34,0:22:50.77,冬青黑体简体中文,,0,0,0,,这会返回同这里基本一样的东西\N{\fs14}That returns essentially the same thing as here,
Dialogue: 0,0:22:50.77,0:22:53.18,冬青黑体简体中文,,0,0,0,,你也许可以说\N{\fs14}and you probably could say
Dialogue: 0,0:22:53.18,0:22:55.66,冬青黑体简体中文,,0,0,0,,isKindOfClass 开方括号 实例方法class\N{\fs14}is kind of class open square bracket instance method class.
Dialogue: 0,0:22:55.66,0:22:58.91,冬青黑体简体中文,,0,0,0,,但你的读者会对此非常不解\N{\fs14}But your reader would pretty darn confused by that.
Dialogue: 0,0:22:58.91,0:23:03.33,冬青黑体简体中文,,0,0,0,,这里有实例方法和类方法 我想都返回相同的东西\N{\fs14}So there's an instance method and a class method; probably both return the same thing,
Dialogue: 0,0:23:03.33,0:23:04.70,冬青黑体简体中文,,0,0,0,,大写C的Class\N{\fs14}capital C class, I believe.
Dialogue: 0,0:23:04.70,0:23:08.44,冬青黑体简体中文,,0,0,0,,但我们这里不会这样做 不要在这里调用实例方法\N{\fs14}But we would never do that here, so don't put an instance call there,
Dialogue: 0,0:23:08.44,0:23:10.38,冬青黑体简体中文,,0,0,0,,仅使用类方法\N{\fs14}just the class method you want.
Dialogue: 0,0:23:10.38,0:23:12.35,冬青黑体简体中文,,0,0,0,,问得很好\N{\fs14}Good question.
Dialogue: 0,0:23:12.35,0:23:15.13,冬青黑体简体中文,,0,0,0,,再来看方法的情况\N{\fs14}All right. How about the selector one, the method one rather?
Dialogue: 0,0:23:15.13,0:23:19.18,冬青黑体简体中文,,0,0,0,,这类函数对选择某事物作出反应时所使用的\N{\fs14}Okay. So methods, when we use them in this response to select a thing,
Dialogue: 0,0:23:19.18,0:23:20.44,冬青黑体简体中文,,0,0,0,,叫作selector(选择器)\N{\fs14}we call them "selectors."
Dialogue: 0,0:23:20.44,0:23:25.24,冬青黑体简体中文,,0,0,0,,selector可以说是一个方法名的识别器\N{\fs14}A selector is really kind of an identifier for a method name
Dialogue: 0,0:23:25.24,0:23:27.54,冬青黑体简体中文,,0,0,0,,以方法shoot为例\N{\fs14}because if you have the method shoot,
Dialogue: 0,0:23:27.54,0:23:31.52,冬青黑体简体中文,,0,0,0,,不管你考虑哪种实现它的类 selector都是一样的\N{\fs14}it's the same selector no matter what class you're talking about implementing it in.
Dialogue: 0,0:23:31.52,0:23:34.99,冬青黑体简体中文,,0,0,0,,哪怕它们之间没有继承关系 完全无关\N{\fs14}Even if they don't inherit from each other, they're completely unrelated.
Dialogue: 0,0:23:35.01,0:23:36.96,冬青黑体简体中文,,0,0,0,,例如一个Gun(枪)类拥有shoot方法\N{\fs14}You might have a gun class that says shoot
Dialogue: 0,0:23:36.96,0:23:38.82,冬青黑体简体中文,,0,0,0,,还有一个Ship类拥有shoot方法\N{\fs14}and you might have a ship class that says shoot --
Dialogue: 0,0:23:38.82,0:23:40.46,冬青黑体简体中文,,0,0,0,,shoot的selector是一样的\N{\fs14}the selector shoot would be the same.
Dialogue: 0,0:23:40.46,0:23:42.12,冬青黑体简体中文,,0,0,0,,获得selector的方式是\N{\fs14}And we get that selector by saying
Dialogue: 0,0:23:42.12,0:23:46.52,冬青黑体简体中文,,0,0,0,,用@selector(方法名)\N{\fs14}at sign selector parenthesis, the name of the method.
Dialogue: 0,0:23:46.52,0:23:47.51,冬青黑体简体中文,,0,0,0,,例如shoot\N{\fs14}Shoot.
Dialogue: 0,0:23:47.51,0:23:50.82,冬青黑体简体中文,,0,0,0,,如果方法有多个参数 我们只需将冒号加到这里\N{\fs14}And if the method has multiple arguments, we just put the colons in there.
Dialogue: 0,0:23:50.82,0:23:53.86,冬青黑体简体中文,,0,0,0,,例如shootAt:有一个参数\N{\fs14}So shoot at colon has one argument
Dialogue: 0,0:23:53.86,0:23:56.70,冬青黑体简体中文,,0,0,0,,或者addCard: atTop:\N{\fs14}or add card colon at top colon.
Dialogue: 0,0:23:56.70,0:23:57.99,冬青黑体简体中文,,0,0,0,,我们只需要写\N{\fs14}We just say that,
Dialogue: 0,0:23:57.99,0:24:02.11,冬青黑体简体中文,,0,0,0,,@selector(addCard: atTop:)\N{\fs14}at sign selector, open parenthesis, add card colon, add top colon, close parenthesis.
Dialogue: 0,0:24:02.11,0:24:04.14,冬青黑体简体中文,,0,0,0,,这会给我们selector\N{\fs14}And that gives us the selector,
Dialogue: 0,0:24:04.14,0:24:06.47,冬青黑体简体中文,,0,0,0,,然后我们说respondsToSelector\N{\fs14}and we say responds to selector.
Dialogue: 0,0:24:06.49,0:24:07.45,冬青黑体简体中文,,0,0,0,,这会告诉我们\N{\fs14}And that will tell us whether the
Dialogue: 0,0:24:07.45,0:24:10.42,冬青黑体简体中文,,0,0,0,,我们发送给respondsToSelector的对象\N{\fs14}object that we're sending responds to selector
Dialogue: 0,0:24:10.42,0:24:12.29,冬青黑体简体中文,,0,0,0,,是否对此方法作出反应\N{\fs14}to responds to that method.
Dialogue: 0,0:24:12.29,0:24:15.42,冬青黑体简体中文,,0,0,0,,这些selector实际上是一种类型\N{\fs14}Now, these selectors, there's actually a type,
Dialogue: 0,0:24:15.42,0:24:18.42,冬青黑体简体中文,,0,0,0,,这些selector在Objective-C中是一种typedef\N{\fs14}kind of a type def in Objective-C for these selectors.
Dialogue: 0,0:24:18.42,0:24:21.16,冬青黑体简体中文,,0,0,0,,全大写SEL 同全大写BOOL一样\N{\fs14}All caps SEL, kind of like all caps BOOL, right?
Dialogue: 0,0:24:21.16,0:24:23.55,冬青黑体简体中文,,0,0,0,,这里加入了这种typedef\N{\fs14}So this type def thing is added.
Dialogue: 0,0:24:23.55,0:24:29.46,冬青黑体简体中文,,0,0,0,,你可以声明类型为SEL的变量 并将事物存储于其中\N{\fs14}And you can declare variables that are of type SEL and store things in there.
Dialogue: 0,0:24:29.46,0:24:32.88,冬青黑体简体中文,,0,0,0,,实际上还有respondsToSelector之外的其它方法\N{\fs14}And there are actually other methods besides respond to selector
Dialogue: 0,0:24:32.88,0:24:34.63,冬青黑体简体中文,,0,0,0,,将selector作为参数\N{\fs14}that take a selector.
Dialogue: 0,0:24:34.63,0:24:38.12,冬青黑体简体中文,,0,0,0,,例如 对象有performSelector:\N{\fs14}For example, object has perform selector
Dialogue: 0,0:24:38.12,0:24:40.79,冬青黑体简体中文,,0,0,0,,以及performSelector:withObject:\N{\fs14}and perform selector with object.
Dialogue: 0,0:24:40.79,0:24:45.52,冬青黑体简体中文,,0,0,0,,它们会将这一方法执行到另一个对象上\N{\fs14}They will perform that method on another object.
Dialogue: 0,0:24:45.52,0:24:46.84,冬青黑体简体中文,,0,0,0,,为什么要这样做呢\N{\fs14}Now, why would you ever want to do this?
Dialogue: 0,0:24:46.84,0:24:49.17,冬青黑体简体中文,,0,0,0,,因为你可能有一些参数化的东西\N{\fs14}Well, you might have some parameterized thing
Dialogue: 0,0:24:49.17,0:24:51.44,冬青黑体简体中文,,0,0,0,,你要处理三种不同方法中的一个\N{\fs14}where you're going to do one of three different methods,
Dialogue: 0,0:24:51.44,0:24:53.21,冬青黑体简体中文,,0,0,0,,取决于用户的选择\N{\fs14}depending on something the user chooses.
Dialogue: 0,0:24:53.21,0:24:54.93,冬青黑体简体中文,,0,0,0,,你可以说performSelector\N{\fs14}And you can say perform selector
Dialogue: 0,0:24:54.93,0:24:59.01,冬青黑体简体中文,,0,0,0,,然后有三个SEL变量 对应每种方法\N{\fs14}and then have three SEL variables, one for each method,
Dialogue: 0,0:24:59.01,0:25:01.72,冬青黑体简体中文,,0,0,0,,将这作为performSelector的参数\N{\fs14}and pass that as the argument you want to perform selector.
Dialogue: 0,0:25:01.72,0:25:03.54,冬青黑体简体中文,,0,0,0,,performSelector: withObject:\N{\fs14}Perform selector with object,
Dialogue: 0,0:25:03.54,0:25:05.55,冬青黑体简体中文,,0,0,0,,这一方法有一个参数\N{\fs14}that method would have one argument.
Dialogue: 0,0:25:05.55,0:25:08.17,冬青黑体简体中文,,0,0,0,,selector名应该是某某冒号\N{\fs14}So the selector name better be something colon
Dialogue: 0,0:25:08.17,0:25:09.43,冬青黑体简体中文,,0,0,0,,因为它有一个参数\N{\fs14}because it's got one argument.
Dialogue: 0,0:25:09.43,0:25:11.34,冬青黑体简体中文,,0,0,0,,而参数必须是一个对象\N{\fs14}And the argument has to be an object.
Dialogue: 0,0:25:11.34,0:25:14.39,冬青黑体简体中文,,0,0,0,,coordinate在这里是某种对象\N{\fs14}So coordinate here would be some sort of object.
Dialogue: 0,0:25:14.39,0:25:16.14,冬青黑体简体中文,,0,0,0,,这里有一点限制\N{\fs14}So just a little limitation.
Dialogue: 0,0:25:16.14,0:25:19.29,冬青黑体简体中文,,0,0,0,,方法要么没有参数 要么有一个对象作为参数\N{\fs14}It can only have no arguments or have one argument that's an object.
Dialogue: 0,0:25:19.29,0:25:23.06,冬青黑体简体中文,,0,0,0,,你还可以让数组做如下很酷的事\N{\fs14}You can also do cool things like ask an array
Dialogue: 0,0:25:23.06,0:25:28.04,冬青黑体简体中文,,0,0,0,,让数组中所有对象执行这个selector\N{\fs14}make all the objects in yourself perform this selector.
Dialogue: 0,0:25:28.04,0:25:29.61,冬青黑体简体中文,,0,0,0,,这是一个很酷的方法\N{\fs14}This is a very cool method.
Dialogue: 0,0:25:29.61,0:25:32.63,冬青黑体简体中文,,0,0,0,,如果你能习惯在数组中使用这样的方法\N{\fs14}And if you get used to using methods like this in Array,
Dialogue: 0,0:25:32.63,0:25:35.47,冬青黑体简体中文,,0,0,0,,你的代码量会大幅减少\N{\fs14}you'll find your code will shrink down really small
Dialogue: 0,0:25:35.47,0:25:37.59,冬青黑体简体中文,,0,0,0,,因为for in循环这些\N{\fs14}because, you know, for ins and things
Dialogue: 0,0:25:37.59,0:25:40.38,冬青黑体简体中文,,0,0,0,,会缩减为这样的一行代码\N{\fs14}like that you have to really zoomed down to one-liners,
Dialogue: 0,0:25:40.38,0:25:42.22,冬青黑体简体中文,,0,0,0,,makeObjectsPerformSelector:\N{\fs14}make objects perform selector, okay,
Dialogue: 0,0:25:42.22,0:25:44.43,冬青黑体简体中文,,0,0,0,,或makeObjectsPerformSelector: withObject:\N{\fs14}or make object perform selector with object.
Dialogue: 0,0:25:44.43,0:25:46.67,冬青黑体简体中文,,0,0,0,,这是NSArray的方法\N{\fs14}So that's an NSArray thing.
Dialogue: 0,0:25:46.67,0:25:49.29,冬青黑体简体中文,,0,0,0,,显然 我们还用selector处理目标动作\N{\fs14}And of course, we do target action with selectors.
Dialogue: 0,0:25:49.29,0:25:52.43,冬青黑体简体中文,,0,0,0,,如果你想设置目标动作\N{\fs14}The method, if you wanted to set up target action,
Dialogue: 0,0:25:52.43,0:25:55.12,冬青黑体简体中文,,0,0,0,,不用Control拖动 而是在代码中设置\N{\fs14}not doing control drag but actually setting up in code,
Dialogue: 0,0:25:55.12,0:25:58.91,冬青黑体简体中文,,0,0,0,,方法在UIControl中 按钮就是继承自这里\N{\fs14}is in UI control actually, which button inheritance from.
Dialogue: 0,0:25:58.91,0:26:01.28,冬青黑体简体中文,,0,0,0,,addTarget: action:\N{\fs14}Add target colon, action colon.
Dialogue: 0,0:26:01.28,0:26:02.58,冬青黑体简体中文,,0,0,0,,还有其它一些参数\N{\fs14}There's some other arguments.
Dialogue: 0,0:26:02.58,0:26:05.02,冬青黑体简体中文,,0,0,0,,不过addTarget:的参数是id类型\N{\fs14}But you can see that add target takes an ID
Dialogue: 0,0:26:05.02,0:26:07.88,冬青黑体简体中文,,0,0,0,,然后action:的参数是selector\N{\fs14}and then it takes an action colon, takes a selector.
Dialogue: 0,0:26:07.88,0:26:10.60,冬青黑体简体中文,,0,0,0,,它会说明 什么消息发送到什么对象\N{\fs14}So it says what message to send to what object --
Dialogue: 0,0:26:10.60,0:26:13.38,冬青黑体简体中文,,0,0,0,,什么是目标 什么是动作\N{\fs14}what's the target, what's the action?
Dialogue: 0,0:26:13.38,0:26:16.27,冬青黑体简体中文,,0,0,0,,大家都理解了吗\N{\fs14}Everyone understand that?
Dialogue: 0,0:26:16.27,0:26:19.02,冬青黑体简体中文,,0,0,0,,这是选择\N{\fs14}Okay. So this selection stuff,
Dialogue: 0,0:26:19.02,0:26:21.66,冬青黑体简体中文,,0,0,0,,selector非常强大\N{\fs14}pretty selector stuff is pretty powerful.
Dialogue: 0,0:26:21.66,0:26:24.31,冬青黑体简体中文,,0,0,0,,下面我们来看match\N{\fs14}All right. So let's take a look at how match --
Dialogue: 0,0:26:24.31,0:26:25.75,冬青黑体简体中文,,0,0,0,,PlayingCard中的match\N{\fs14}the playing card match --
Dialogue: 0,0:26:25.75,0:26:27.37,冬青黑体简体中文,,0,0,0,,如何用内省来改善\N{\fs14}might be improved with introspection.
Dialogue: 0,0:26:27.37,0:26:31.56,冬青黑体简体中文,,0,0,0,,我将回到Xcode\N{\fs14}I'm going to go here back to Xcode.
Dialogue: 0,0:26:34.32,0:26:38.32,冬青黑体简体中文,,0,0,0,,打开之前我们编辑过的Machismo\N{\fs14}And I'm just going to open back up Machismo where we left off here.
Dialogue: 0,0:26:45.91,0:26:49.45,冬青黑体简体中文,,0,0,0,,然后在下面找到PlayingCard\N{\fs14}Okay. And then let's go down to playing card.
Dialogue: 0,0:26:49.45,0:26:51.58,冬青黑体简体中文,,0,0,0,,这是PlayingCard 这是match\N{\fs14}So here's playing card and here's match.
Dialogue: 0,0:26:51.58,0:26:53.26,冬青黑体简体中文,,0,0,0,,都记得match吧\N{\fs14}Okay. So you all remember match.
Dialogue: 0,0:26:53.26,0:26:56.36,冬青黑体简体中文,,0,0,0,,这一行代码有一点问题\N{\fs14}And here's the line of code that's a little bit of trouble.
Dialogue: 0,0:26:56.36,0:27:00.58,冬青黑体简体中文,,0,0,0,,因为这里第一个对象 它会返回一个id\N{\fs14}Because this first object here, this returns an ID.
Dialogue: 0,0:27:00.58,0:27:06.65,冬青黑体简体中文,,0,0,0,,所以我们可以这样做 id card = 这个\N{\fs14}So what we could do here, for example, is we could say ID card equals this.
Dialogue: 0,0:27:09.14,0:27:11.84,冬青黑体简体中文,,0,0,0,,我要让这里完全清晰\N{\fs14}Just to be totally clear here.
Dialogue: 0,0:27:11.84,0:27:13.76,冬青黑体简体中文,,0,0,0,,我得到了这个card 然后我说\N{\fs14}So we got this card. And then I can say
Dialogue: 0,0:27:13.77,0:27:19.32,冬青黑体简体中文,,0,0,0,,if ([card isKindOfClass:[PlayingCard class]])\N{\fs14}if card is kind of class, playing card class,
Dialogue: 0,0:27:19.32,0:27:22.33,冬青黑体简体中文,,0,0,0,,那么 我将做所有这些\N{\fs14}okay, then I'll do all this.
Dialogue: 0,0:27:25.67,0:27:29.28,冬青黑体简体中文,,0,0,0,,而且我要将另外这张牌设为\N{\fs14}And I'm going to set the other card here to be
Dialogue: 0,0:27:29.28,0:27:32.51,冬青黑体简体中文,,0,0,0,,(PlayingCard *)card\N{\fs14}playing card, star card.
Dialogue: 0,0:27:32.51,0:27:34.91,冬青黑体简体中文,,0,0,0,,这里是类型转换\N{\fs14}So I'm going to cast it.
Dialogue: 0,0:27:34.91,0:27:37.86,冬青黑体简体中文,,0,0,0,,这时编译器就知道了这个变量\N{\fs14}So now the compiler knows about this variable.
Dialogue: 0,0:27:37.86,0:27:40.25,冬青黑体简体中文,,0,0,0,,从这里开始 当我触摸另一张牌时\N{\fs14}And from here on out, whenever I touch other card,
Dialogue: 0,0:27:40.25,0:27:41.96,冬青黑体简体中文,,0,0,0,,它都会知道这张牌是PlayingCard\N{\fs14}it knows it's going to be a playing card.
Dialogue: 0,0:27:41.96,0:27:45.21,冬青黑体简体中文,,0,0,0,,而这里 我在运行时检验 以保证它是PlayingCard\N{\fs14}And here I've checked at runtime to make sure that it's actually the playing card
Dialogue: 0,0:27:45.21,0:27:47.09,冬青黑体简体中文,,0,0,0,,这样这里就永远不会崩溃\N{\fs14}so that I'll never crash here.
Dialogue: 0,0:27:47.09,0:27:50.30,冬青黑体简体中文,,0,0,0,,如果你说 match:otherCards\N{\fs14}Now, if you say match colon other cards
Dialogue: 0,0:27:50.30,0:27:53.33,冬青黑体简体中文,,0,0,0,,而otherCards不是PlayingCard(扑克牌)\N{\fs14}and the other cards are like, some not playing cards,
Dialogue: 0,0:27:53.33,0:27:57.24,冬青黑体简体中文,,0,0,0,,例如只是普通卡片 或是字符串 这不会有问题\N{\fs14}they're regular cards or they're strings or something, then that's okay.
Dialogue: 0,0:27:57.24,0:27:58.50,冬青黑体简体中文,,0,0,0,,这个方法能够运行\N{\fs14}This method's going to work fine because it's going
Dialogue: 0,0:27:58.50,0:28:00.65,冬青黑体简体中文,,0,0,0,,因为它会返回0 分数为0 这是对的\N{\fs14}to return zero, a score of zero, which is right
Dialogue: 0,0:28:00.65,0:28:04.19,冬青黑体简体中文,,0,0,0,,因为扑克牌不能同字符串或普通卡片匹配上\N{\fs14}because a playing card wouldn't match a string or any other kind of card.
Dialogue: 0,0:28:05.58,0:28:06.74,冬青黑体简体中文,,0,0,0,,能理解吗\N{\fs14}Make sense?
Dialogue: 0,0:28:06.74,0:28:09.02,冬青黑体简体中文,,0,0,0,,明白这里是如何使用内省的吗\N{\fs14}See how we used introspection there?
Dialogue: 0,0:28:09.02,0:28:13.52,冬青黑体简体中文,,0,0,0,,你们将会在下周的作业中用到内省\N{\fs14}So you will have to use introspection most likely in your solution to next week's homework --
Dialogue: 0,0:28:13.52,0:28:15.07,冬青黑体简体中文,,0,0,0,,不是现在你们在做的这次\N{\fs14}not the one you're currently working on.
Dialogue: 0,0:28:15.07,0:28:18.03,冬青黑体简体中文,,0,0,0,,顺便我需要说明一下\N{\fs14}By the way, I should take time out to say I'd almost --
Dialogue: 0,0:28:18.03,0:28:20.46,冬青黑体简体中文,,0,0,0,,我在课堂上讲的内容\N{\fs14}if I ever show you something in a lecture
Dialogue: 0,0:28:20.46,0:28:25.37,冬青黑体简体中文,,0,0,0,,在我布置以后 这几乎从不需要用在当周的作业中\N{\fs14}after I've assigned something to you, you almost never need it in that week's homework.
Dialogue: 0,0:28:25.37,0:28:27.98,冬青黑体简体中文,,0,0,0,,否则我会另行通知你们\N{\fs14}And I would tell you if that were the case.
Dialogue: 0,0:28:27.98,0:28:29.90,冬青黑体简体中文,,0,0,0,,懂我说的吗\N{\fs14}You know what I'm saying?
Dialogue: 0,0:28:29.90,0:28:32.04,冬青黑体简体中文,,0,0,0,,例如 周一布置的作业\N{\fs14}So, like, you've got an assignment on Monday;
Dialogue: 0,0:28:32.04,0:28:35.41,冬青黑体简体中文,,0,0,0,,我不会今天讲一些东西 让你们用在周一的作业中\N{\fs14}I wouldn't be showing you things today that you needed for the assignment on Monday.
Dialogue: 0,0:28:35.41,0:28:39.76,冬青黑体简体中文,,0,0,0,,布置作业时 这次作业所需的内容就已经都讲过了\N{\fs14}I've already shown you everything you need by the time you get the assignment.
Dialogue: 0,0:28:39.76,0:28:40.54,冬青黑体简体中文,,0,0,0,,有问题\N{\fs14}Question?
Dialogue: 0,0:28:45.36,0:28:47.96,冬青黑体简体中文,,0,0,0,,问题是 内省是不是只用于\N{\fs14}Okay. So the question is: Is introspection only used
Dialogue: 0,0:28:47.96,0:28:50.16,冬青黑体简体中文,,0,0,0,,从数组中选出项目这样的时候\N{\fs14}like this when you're pulling items out of Array?
Dialogue: 0,0:28:50.16,0:28:52.08,冬青黑体简体中文,,0,0,0,,记得吧 两张幻灯片前我讲了\N{\fs14}And remember, I told you a couple slides ago
Dialogue: 0,0:28:52.08,0:28:55.39,冬青黑体简体中文,,0,0,0,,我们主要有两种时候用到内省 一是这个\N{\fs14}there are two major times when we use introspection -- one is this.
Dialogue: 0,0:28:55.39,0:28:59.38,冬青黑体简体中文,,0,0,0,,二是所有MVC盲通信\N{\fs14}Second one is all that MVC blind communication, right?
Dialogue: 0,0:28:59.38,0:29:03.67,冬青黑体简体中文,,0,0,0,,目标动作 委托等等那些\N{\fs14}Target action, and delegation, and all that stuff.
Dialogue: 0,0:29:03.67,0:29:06.06,冬青黑体简体中文,,0,0,0,,这是这部分内容\N{\fs14}So that's that.
Dialogue: 0,0:29:06.06,0:29:08.03,冬青黑体简体中文,,0,0,0,,下面转入Foundation\N{\fs14}Now let's move onto Foundation.
Dialogue: 0,0:29:08.03,0:29:10.62,冬青黑体简体中文,,0,0,0,,这里我们要讨论Foundation框架\N{\fs14}So we're going to talk about a Foundation framework here.
Dialogue: 0,0:29:10.62,0:29:14.63,冬青黑体简体中文,,0,0,0,,我将很快过一遍对象 数组 字典等等这些\N{\fs14}I'm going to really go fast through object, Array, dictionary, things like that
Dialogue: 0,0:29:14.63,0:29:16.86,冬青黑体简体中文,,0,0,0,,因为我们已经见过很多数组\N{\fs14}because we've already seen a lot of Array.
Dialogue: 0,0:29:16.86,0:29:18.95,冬青黑体简体中文,,0,0,0,,你们应该已经知道它是什么了\N{\fs14}I think you pretty much got a good feel for what it is.
Dialogue: 0,0:29:18.95,0:29:20.87,冬青黑体简体中文,,0,0,0,,所以我不会花太多时间讲\N{\fs14}So I don't want to waste the time talking about that.
Dialogue: 0,0:29:20.87,0:29:22.92,冬青黑体简体中文,,0,0,0,,我们有很多新东西要讲\N{\fs14}We got a lot more new stuff to talk about.
Dialogue: 0,0:29:22.92,0:29:25.58,冬青黑体简体中文,,0,0,0,,你们知道NSObject是所有对象的基类\N{\fs14}But you know that NSObject is the base class for all objects.
Dialogue: 0,0:29:25.58,0:29:28.40,冬青黑体简体中文,,0,0,0,,它实现内省这些东西\N{\fs14}It implements those introspection things.
Dialogue: 0,0:29:28.40,0:29:30.58,冬青黑体简体中文,,0,0,0,,它还实现了这个很重要的方法\N{\fs14}It also implements this very important method
Dialogue: 0,0:29:30.58,0:29:31.86,冬青黑体简体中文,,0,0,0,,叫作description(描述)\N{\fs14}called description.
Dialogue: 0,0:29:31.86,0:29:35.05,冬青黑体简体中文,,0,0,0,,description会返回一个NSString\N{\fs14}So description, it just returns an NSString.
Dialogue: 0,0:29:35.05,0:29:39.54,冬青黑体简体中文,,0,0,0,,它返回的字符串用于描绘这个对象\N{\fs14}And it's supposed to return a string that describes this object.
Dialogue: 0,0:29:39.54,0:29:41.67,冬青黑体简体中文,,0,0,0,,什么时候用这个呢\N{\fs14}When do we ever use this?
Dialogue: 0,0:29:41.67,0:29:44.21,冬青黑体简体中文,,0,0,0,,两个地方 一是NSLog\N{\fs14}Two places. One, NS log.
Dialogue: 0,0:29:44.23,0:29:47.87,冬青黑体简体中文,,0,0,0,,调试时 我们喜欢用NSLog %@\N{\fs14}When we're debugging, we like to NS log percent at sign.
Dialogue: 0,0:29:47.89,0:29:49.71,冬青黑体简体中文,,0,0,0,,用%@时\N{\fs14}And when we do percent at sign,
Dialogue: 0,0:29:49.71,0:29:53.45,冬青黑体简体中文,,0,0,0,,description会被发送给匹配对象\N{\fs14}the matching objects get sent description, and that's what gets sent out.
Dialogue: 0,0:29:53.45,0:29:58.99,冬青黑体简体中文,,0,0,0,,NSString通过返回self来实现description\N{\fs14}Now, NSString implements a description by returning self.
Dialogue: 0,0:29:58.99,0:30:02.42,冬青黑体简体中文,,0,0,0,,NSObject对description的实现非常糟糕\N{\fs14}NSObject implements description very badly.
Dialogue: 0,0:30:02.42,0:30:04.30,冬青黑体简体中文,,0,0,0,,它会返回指针\N{\fs14}It returns like the pointer,
Dialogue: 0,0:30:04.30,0:30:07.42,冬青黑体简体中文,,0,0,0,,带有指针的字符串这之类\N{\fs14}a string with the pointer in it or something.
Dialogue: 0,0:30:07.42,0:30:10.94,冬青黑体简体中文,,0,0,0,,在你自己的类中实现时 description会很有用\N{\fs14}Description becomes valuable when you implement it in your own classes.
Dialogue: 0,0:30:10.94,0:30:14.53,冬青黑体简体中文,,0,0,0,,例如在PlayingCard中 你可以实现description\N{\fs14}So you could imagine implementing in playing card,
Dialogue: 0,0:30:14.53,0:30:16.63,冬青黑体简体中文,,0,0,0,,甚至在Card中 你也可以实现description\N{\fs14}or even in card you could implement description
Dialogue: 0,0:30:16.63,0:30:18.95,冬青黑体简体中文,,0,0,0,,返回self.contents\N{\fs14}that would return self.contents.
Dialogue: 0,0:30:18.95,0:30:22.12,冬青黑体简体中文,,0,0,0,,然后在调试器中 你就能够…\N{\fs14}And then in the debugger there's a way --
Dialogue: 0,0:30:22.12,0:30:24.44,冬青黑体简体中文,,0,0,0,,周五的课上你们会看到\N{\fs14}in which you'll see this Friday's section --
Dialogue: 0,0:30:24.44,0:30:26.53,冬青黑体简体中文,,0,0,0,,你就能够在调试器中打印一个对象\N{\fs14}there's a way to print an object in the debugger.
Dialogue: 0,0:30:26.53,0:30:28.63,冬青黑体简体中文,,0,0,0,,它会为你调用description 并返回它\N{\fs14}It will call description for you and return it.
Dialogue: 0,0:30:28.63,0:30:31.33,冬青黑体简体中文,,0,0,0,,于是你就能看到纸牌的内容 这非常酷\N{\fs14}So for card you'd see the contents. So that's really cool.
Dialogue: 0,0:30:31.33,0:30:32.90,冬青黑体简体中文,,0,0,0,,而字符串显示的是字符串\N{\fs14}And the string shows you the string.
Dialogue: 0,0:30:32.90,0:30:35.13,冬青黑体简体中文,,0,0,0,,数组和字典实现description时\N{\fs14}Arrays and dictionaries implement description
Dialogue: 0,0:30:35.13,0:30:37.97,冬青黑体简体中文,,0,0,0,,会打印出数组内容\N{\fs14}to print out the contents of the array.
Dialogue: 0,0:30:37.97,0:30:42.04,冬青黑体简体中文,,0,0,0,,所以说description是NSObject中很酷的函数\N{\fs14}So description's a really cool little function to know about in NSObject.
Dialogue: 0,0:30:42.04,0:30:46.77,冬青黑体简体中文,,0,0,0,,NSObject还实现了这种复制框架\N{\fs14}NSObject kind of implements this framework for copying,
Dialogue: 0,0:30:46.77,0:30:49.58,冬青黑体简体中文,,0,0,0,,但它并没有实际实现copy和mutableCopy\N{\fs14}but it doesn't actually implement copy and mutable copy.
Dialogue: 0,0:30:49.58,0:30:51.78,冬青黑体简体中文,,0,0,0,,查一下NSObject你就会知道\N{\fs14}If you look in NSObject, you'll see that
Dialogue: 0,0:30:51.78,0:30:55.38,冬青黑体简体中文,,0,0,0,,这些方法在这里有一个协议\N{\fs14}these methods are implemented there or there's a protocol for them there.
Dialogue: 0,0:30:55.38,0:30:59.16,冬青黑体简体中文,,0,0,0,,copy和mutableCopy\N{\fs14}Copy and mutable copy are --
Dialogue: 0,0:30:59.16,0:31:01.82,冬青黑体简体中文,,0,0,0,,它们的语义在不同类中有所不同\N{\fs14}the semantics of them vary from class to class.
Dialogue: 0,0:31:01.82,0:31:04.64,冬青黑体简体中文,,0,0,0,,其实现取决于类\N{\fs14}So it's up the class to implement it.
Dialogue: 0,0:31:04.64,0:31:07.33,冬青黑体简体中文,,0,0,0,,不要被NSObject中的copy和mutableCopy糊弄到\N{\fs14}Don't be fooled by the fact that copy and mutable copy are in NSObject.
Dialogue: 0,0:31:07.33,0:31:10.04,冬青黑体简体中文,,0,0,0,,不是将copy发送给任何对象就能复制的\N{\fs14}You can't just send copy to any object and it will copy it.
Dialogue: 0,0:31:10.04,0:31:13.14,冬青黑体简体中文,,0,0,0,,但NSArray NSDictionary这些\N{\fs14}But NSArray, for example, NSDictionary, these things,
Dialogue: 0,0:31:13.14,0:31:14.85,冬青黑体简体中文,,0,0,0,,实现了copy和mutableCopy\N{\fs14}they implement copy and mutable copy,
Dialogue: 0,0:31:14.85,0:31:16.55,冬青黑体简体中文,,0,0,0,,它们做了正确的事情\N{\fs14}and they do the right thing.
Dialogue: 0,0:31:16.55,0:31:19.73,冬青黑体简体中文,,0,0,0,,关于copy有一点要注意 如果将copy\N{\fs14}One thing to note about copy is if you send copy
Dialogue: 0,0:31:19.73,0:31:22.43,冬青黑体简体中文,,0,0,0,,发送给一个可变对象 例如可变数组\N{\fs14}to a mutable object like a mutable array,
Dialogue: 0,0:31:22.43,0:31:24.51,冬青黑体简体中文,,0,0,0,,返回的将不是可变数组\N{\fs14}you don't get a mutable array back,
Dialogue: 0,0:31:24.51,0:31:26.09,冬青黑体简体中文,,0,0,0,,虽然你是在copy可变数组\N{\fs14}even though you just copied a mutable array.
Dialogue: 0,0:31:26.09,0:31:28.76,冬青黑体简体中文,,0,0,0,,返回的却是不可变数组\N{\fs14}You get an immutable array back.
Dialogue: 0,0:31:28.76,0:31:30.50,冬青黑体简体中文,,0,0,0,,copy的语义是\N{\fs14}The semantics copy are,
Dialogue: 0,0:31:30.50,0:31:35.06,冬青黑体简体中文,,0,0,0,,如果可能 返回该对象的一个不可变副本\N{\fs14}"Give me an immutable copy of this object back if possible."
Dialogue: 0,0:31:35.06,0:31:37.47,冬青黑体简体中文,,0,0,0,,mutableCopy的语义是\N{\fs14}The semantics of mutable copy are,
Dialogue: 0,0:31:37.47,0:31:40.64,冬青黑体简体中文,,0,0,0,,返回该对象的一个可变副本\N{\fs14}"Give me a mutable copy of this thing."
Dialogue: 0,0:31:40.64,0:31:43.21,冬青黑体简体中文,,0,0,0,,不管接收可变或不可变复制的是什么\N{\fs14}No matter whether the receiver is mutable or immutable,
Dialogue: 0,0:31:43.21,0:31:45.72,冬青黑体简体中文,,0,0,0,,mutableCopy意味着返回可变副本\N{\fs14}mutable copy means give me a mutable copy;
Dialogue: 0,0:31:45.72,0:31:48.19,冬青黑体简体中文,,0,0,0,,copy意味着返回不可变副本\N{\fs14}copy means give me an immutable copy.
Dialogue: 0,0:31:48.19,0:31:51.25,冬青黑体简体中文,,0,0,0,,理解了吗\N{\fs14}Understand that?
Dialogue: 0,0:31:51.25,0:31:54.82,冬青黑体简体中文,,0,0,0,,重申一次 特定类实现这个\N{\fs14}And again, certain classes implement this;
Dialogue: 0,0:31:54.82,0:31:56.78,冬青黑体简体中文,,0,0,0,,NSObject则没有\N{\fs14}NSObject really does not.
Dialogue: 0,0:31:56.78,0:32:00.17,冬青黑体简体中文,,0,0,0,,如果你希望自己的对象可复制 你需要自己实现\N{\fs14}You would have to implement it yourself if you wanted to have your objects be copyable,
Dialogue: 0,0:32:00.17,0:32:01.76,冬青黑体简体中文,,0,0,0,,这非常罕见\N{\fs14}which is pretty rare by the way.
Dialogue: 0,0:32:01.76,0:32:04.79,冬青黑体简体中文,,0,0,0,,一般不需要这样做\N{\fs14}Really not generally doing that.
Dialogue: 0,0:32:04.79,0:32:07.65,冬青黑体简体中文,,0,0,0,,好 NSArray是对象的有序集合\N{\fs14}Okay. NSArray is an ordered collection of objects.
Dialogue: 0,0:32:07.65,0:32:08.93,冬青黑体简体中文,,0,0,0,,它是不可变的\N{\fs14}It's immutable.
Dialogue: 0,0:32:08.93,0:32:11.04,冬青黑体简体中文,,0,0,0,,NSArray一经创建 其中的对象就会一直保持不变\N{\fs14}When you create an NSArray, whatever objects are in it
Dialogue: 0,0:32:11.04,0:32:13.40,冬青黑体简体中文,,0,0,0,,NSArray一经创建 其中的对象就会一直保持不变\N{\fs14}when you create it, those are the objects that will be in there for life.
Dialogue: 0,0:32:13.40,0:32:16.04,冬青黑体简体中文,,0,0,0,,无法删除 也无法添加任何对象\N{\fs14}You can't remove any, you can't add any.
Dialogue: 0,0:32:16.06,0:32:19.49,冬青黑体简体中文,,0,0,0,,数组中所有对象在堆中都是强存储的\N{\fs14}All objects in an array are held onto strongly in the heap.
Dialogue: 0,0:32:19.49,0:32:22.55,冬青黑体简体中文,,0,0,0,,只要该数组本身处在堆中\N{\fs14}So as long as that array itself is in the heap, okay,
Dialogue: 0,0:32:22.55,0:32:24.83,冬青黑体简体中文,,0,0,0,,只要有强指针指向数组本身\N{\fs14}as long as someone has a strong pointer to the array itself,
Dialogue: 0,0:32:24.83,0:32:27.91,冬青黑体简体中文,,0,0,0,,数组中的所有对象也都会留在堆中\N{\fs14}all the objects that are in the array will stay in the heap as well
Dialogue: 0,0:32:27.91,0:32:31.22,冬青黑体简体中文,,0,0,0,,因为有强指针指向所有这些对象\N{\fs14}because it has strong pointers to all of them.
Dialogue: 0,0:32:31.22,0:32:33.91,冬青黑体简体中文,,0,0,0,,NSArray的创建\N{\fs14}You usually create an NSArray
Dialogue: 0,0:32:33.91,0:32:38.55,冬青黑体简体中文,,0,0,0,,有时会调用类方法 甚至调用alloc init\N{\fs14}by sometimes calling a class method or even alloc init.
Dialogue: 0,0:32:38.55,0:32:43.24,冬青黑体简体中文,,0,0,0,,但最普遍的情况下 我们会使用@[]\N{\fs14}But usually most commonly we do that at sign square bracket thing,
Dialogue: 0,0:32:43.24,0:32:44.84,冬青黑体简体中文,,0,0,0,,例如创建rank字符串时\N{\fs14}like how we created rank strings.
Dialogue: 0,0:32:44.84,0:32:49.39,冬青黑体简体中文,,0,0,0,,记得吧 PlayingCard中的rank字符串\N{\fs14}Remember rank strings in playing card,
Dialogue: 0,0:32:49.39,0:32:51.71,冬青黑体简体中文,,0,0,0,,@ 方括号 然后元素\N{\fs14}at sign, square bracket, and the elements?
Dialogue: 0,0:32:51.71,0:32:53.23,冬青黑体简体中文,,0,0,0,,这就是通常创建数组的方式\N{\fs14}That's usually how we create arrays.
Dialogue: 0,0:32:53.23,0:32:56.11,冬青黑体简体中文,,0,0,0,,有时我们创建数组是通过要其它数组\N{\fs14}Sometimes we'll create arrays by asking other arrays
Dialogue: 0,0:32:56.11,0:32:58.72,冬青黑体简体中文,,0,0,0,,在自身上加一个对象 然后返回新数组\N{\fs14}to add an object to themselves and give us a new array
Dialogue: 0,0:32:58.72,0:33:00.14,冬青黑体简体中文,,0,0,0,,因为这里不可变\N{\fs14}since they can't be mutated;
Dialogue: 0,0:33:00.14,0:33:01.64,冬青黑体简体中文,,0,0,0,,所以必须生成新的并返回\N{\fs14}they have to make a new one and give it back.
Dialogue: 0,0:33:01.64,0:33:02.69,冬青黑体简体中文,,0,0,0,,这是另一种方式\N{\fs14}So that's another way.
Dialogue: 0,0:33:02.69,0:33:07.41,冬青黑体简体中文,,0,0,0,,你们知道基本的count objectAtIndex等方法\N{\fs14}And you know the basic, you know, get the count, object at index.
Dialogue: 0,0:33:07.41,0:33:09.87,冬青黑体简体中文,,0,0,0,,数组中还有很多其它非常酷的方法\N{\fs14}There's a lot of other really cool methods in an array.
Dialogue: 0,0:33:09.87,0:33:12.33,冬青黑体简体中文,,0,0,0,,这个类你们需要非常熟悉才行\N{\fs14}You really should familiarize yourself with this class.
Dialogue: 0,0:33:12.33,0:33:14.04,冬青黑体简体中文,,0,0,0,,这里有很多东西\N{\fs14}Okay. It's a lot of stuff.
Dialogue: 0,0:33:14.04,0:33:15.94,冬青黑体简体中文,,0,0,0,,我讲过makeObjectsPerform\N{\fs14}We talked about make objects perform.
Dialogue: 0,0:33:15.94,0:33:18.57,冬青黑体简体中文,,0,0,0,,这里还有sortedArrayUsingSelector\N{\fs14}There's sorted array using selector.
Dialogue: 0,0:33:18.57,0:33:21.78,冬青黑体简体中文,,0,0,0,,你可以给它一个selector\N{\fs14}So you give it a selector that takes another --
Dialogue: 0,0:33:21.78,0:33:24.85,冬青黑体简体中文,,0,0,0,,它被发送到数组中的每个对象\N{\fs14}that basically gets sent to each object in the array
Dialogue: 0,0:33:24.85,0:33:26.92,冬青黑体简体中文,,0,0,0,,并将数组中另一个对象作为参数\N{\fs14}and takes one of the other objects in the array as an argument.
Dialogue: 0,0:33:26.92,0:33:29.53,冬青黑体简体中文,,0,0,0,,你要确保这里的参数类型正确\N{\fs14}So you got to make sure they have the right type of argument there.
Dialogue: 0,0:33:29.53,0:33:32.94,冬青黑体简体中文,,0,0,0,,它会这样来创建一个排过序的数组\N{\fs14}And it will just use that to create a sorted version of the array
Dialogue: 0,0:33:32.94,0:33:34.67,冬青黑体简体中文,,0,0,0,,并返回这个排过序的新数组\N{\fs14}and give you back a new array that's sorted.
Dialogue: 0,0:33:34.67,0:33:37.68,冬青黑体简体中文,,0,0,0,,只要你有一个selector\N{\fs14}Okay. So one line of code as long as you have a selector
Dialogue: 0,0:33:37.68,0:33:40.46,冬青黑体简体中文,,0,0,0,,针对一个方法 能够对比数组中的两个对象\N{\fs14}for a method that can compare two objects that are in an array,
Dialogue: 0,0:33:40.46,0:33:41.91,冬青黑体简体中文,,0,0,0,,你就能够排序\N{\fs14}you can sort it.
Dialogue: 0,0:33:41.91,0:33:46.60,冬青黑体简体中文,,0,0,0,,NSArray中的这些怪异内容你都需要知道\N{\fs14}So you really should know about all these kind of whacky things in NSArray.
Dialogue: 0,0:33:46.60,0:33:49.41,冬青黑体简体中文,,0,0,0,,NSArray无法被修改\N{\fs14}Now, NSArray can't be modified.
Dialogue: 0,0:33:49.41,0:33:52.42,冬青黑体简体中文,,0,0,0,,这有时存在局限\N{\fs14}Sometimes that's a limitation,
Dialogue: 0,0:33:52.43,0:33:54.33,冬青黑体简体中文,,0,0,0,,但可能没你们想的那么严重\N{\fs14}not as often as you might think.
Dialogue: 0,0:33:54.33,0:33:56.31,冬青黑体简体中文,,0,0,0,,当然 还有一种可变的数组\N{\fs14}But there's a mutable version of Array, of course,
Dialogue: 0,0:33:56.31,0:33:59.50,冬青黑体简体中文,,0,0,0,,叫作NSMutableArray 这个我们也用过\N{\fs14}called NSMutableArray, which we've also used.
Dialogue: 0,0:33:59.50,0:34:03.27,冬青黑体简体中文,,0,0,0,,我们通常使用alloc init来创建它\N{\fs14}We usually create it using alloc init
Dialogue: 0,0:34:03.27,0:34:05.87,冬青黑体简体中文,,0,0,0,,有时我们则会使用arrayWithCapacity\N{\fs14}or sometimes we use Array with capacity.
Dialogue: 0,0:34:05.87,0:34:07.92,冬青黑体简体中文,,0,0,0,,arrayWithCapacity中\N{\fs14}Array with capacity is --
Dialogue: 0,0:34:07.92,0:34:10.70,冬青黑体简体中文,,0,0,0,,容量参数只是性能提示\N{\fs14}that capacity argument is just performance hint.
Dialogue: 0,0:34:10.70,0:34:14.03,冬青黑体简体中文,,0,0,0,,它并没有说 数组最开始只能有那么多项目\N{\fs14}It's not saying that the array starts out with that many items;
Dialogue: 0,0:34:14.04,0:34:16.97,冬青黑体简体中文,,0,0,0,,它只是说 我觉得这个数组中将有100个元素\N{\fs14}it just means, "I think this array is going to have a hundred things in it."
Dialogue: 0,0:34:16.97,0:34:20.15,冬青黑体简体中文,,0,0,0,,创建100个元素的数组 这只是性能提示\N{\fs14}So creating an array with a hundred -- it's a performance hint only.
Dialogue: 0,0:34:20.33,0:34:23.92,冬青黑体简体中文,,0,0,0,,你们知道NSMutableArray继承了NSArray的一切\N{\fs14}You know that NSMutableArray inherits everything from NSArray,
Dialogue: 0,0:34:23.92,0:34:26.01,冬青黑体简体中文,,0,0,0,,当然 它还增加了addObject:\N{\fs14}of course, and then it adds add object,
Dialogue: 0,0:34:26.01,0:34:27.29,冬青黑体简体中文,,0,0,0,,insertObject:\N{\fs14}insert object at,
Dialogue: 0,0:34:27.30,0:34:28.82,冬青黑体简体中文,,0,0,0,,removeObject: atIndex:\N{\fs14}remove object at index.
Dialogue: 0,0:34:28.82,0:34:31.76,冬青黑体简体中文,,0,0,0,,你们还知道 可以使用方括号表示法\N{\fs14}And you know that you can use the square brackets notation,
Dialogue: 0,0:34:31.76,0:34:34.94,冬青黑体简体中文,,0,0,0,,例如 self.cards[index]\N{\fs14}right, like self.cards open square bracket, index,
Dialogue: 0,0:34:34.94,0:34:39.63,冬青黑体简体中文,,0,0,0,,将事物放到数组中 或是从数组中删除\N{\fs14}closed square brackets to both put things into an array and get things out of an array.
Dialogue: 0,0:34:39.63,0:34:43.28,冬青黑体简体中文,,0,0,0,,使用这种表示法其实也就是调用\N{\fs14}And using that notation is really just calling
Dialogue: 0,0:34:43.28,0:34:45.72,冬青黑体简体中文,,0,0,0,,objectAtSubscriptedIndex\N{\fs14}object at subscripted index
Dialogue: 0,0:34:45.72,0:34:47.94,冬青黑体简体中文,,0,0,0,,以及setObjectAtSubscriptedIndex\N{\fs14}and set object at subscripted index.
Dialogue: 0,0:34:47.94,0:34:50.27,冬青黑体简体中文,,0,0,0,,这里不过是在调用这些方法\N{\fs14}Okay. It's just calling those methods; that's all it's doing.
Dialogue: 0,0:34:50.27,0:34:54.42,冬青黑体简体中文,,0,0,0,,但使用方括号表示法让代码更清晰\N{\fs14}But it looks really nice in your code to use those square brackets.
Dialogue: 0,0:34:54.42,0:34:59.21,冬青黑体简体中文,,0,0,0,,枚举 我们知道如何使用for in结构\N{\fs14}Enumeration, we saw how to do this for in business.
Dialogue: 0,0:34:59.21,0:35:01.78,冬青黑体简体中文,,0,0,0,,不要忘记 控制变量\N{\fs14}Don't forget that that control variable
Dialogue: 0,0:35:01.78,0:35:04.59,冬青黑体简体中文,,0,0,0,,例如NSString *string in myArray\N{\fs14}like NSString star string in my array --
Dialogue: 0,0:35:04.59,0:35:06.09,冬青黑体简体中文,,0,0,0,,这里有NSString *string\N{\fs14}you see the NSString star string --
Dialogue: 0,0:35:06.09,0:35:08.44,冬青黑体简体中文,,0,0,0,,这实际上是类型转换\N{\fs14}that's essentially your casting.
Dialogue: 0,0:35:08.44,0:35:11.56,冬青黑体简体中文,,0,0,0,,你将该数组中取出的元素转化为NSString\N{\fs14}You're casting, whatever comes out of that array to be an NSString.
Dialogue: 0,0:35:11.56,0:35:15.41,冬青黑体简体中文,,0,0,0,,你告诉编译器 我知道这个数组中都是字符串\N{\fs14}You're telling the compiler, "I know that what's in that array is strings."
Dialogue: 0,0:35:15.41,0:35:17.57,冬青黑体简体中文,,0,0,0,,如果你不知道数组中都是什么\N{\fs14}Now, if you don't know what's in there,
Dialogue: 0,0:35:17.57,0:35:19.28,冬青黑体简体中文,,0,0,0,,或者如果是混合事物\N{\fs14}you could say -- or if it's a mixed things --
Dialogue: 0,0:35:19.28,0:35:22.53,冬青黑体简体中文,,0,0,0,,你可以说 for (id obj in myArray)\N{\fs14}you would say for ID obj in my array.
Dialogue: 0,0:35:22.53,0:35:24.64,冬青黑体简体中文,,0,0,0,,这时 迭代变量将是obj\N{\fs14}Then the iteration variable will be an obj
Dialogue: 0,0:35:24.65,0:35:27.00,冬青黑体简体中文,,0,0,0,,你可能需要内省来弄清\N{\fs14}and you'll likely want to use introspection to find
Dialogue: 0,0:35:27.00,0:35:30.96,冬青黑体简体中文,,0,0,0,,每次经过循环时 返回给你的东西是什么\N{\fs14}out what the thing you got back is each time around the loop.
Dialogue: 0,0:35:30.96,0:35:33.33,冬青黑体简体中文,,0,0,0,,能理解吗\N{\fs14}Make sense?
Dialogue: 0,0:35:33.33,0:35:35.68,冬青黑体简体中文,,0,0,0,,下一个 NSNumber\N{\fs14}Next NSNumber.
Dialogue: 0,0:35:35.68,0:35:40.40,冬青黑体简体中文,,0,0,0,,NSNumber这个类被用于包含原始类型\N{\fs14}NSNumber is a class that is used to wrap primitive types
Dialogue: 0,0:35:40.40,0:35:42.89,冬青黑体简体中文,,0,0,0,,例如整型 浮点型 双精浮点型 布尔型等等\N{\fs14}like integers, floats, doubles, Bools, things like that.
Dialogue: 0,0:35:42.89,0:35:44.28,冬青黑体简体中文,,0,0,0,,为什么要把这些总起来呢\N{\fs14}And why do you want to wrap them?
Dialogue: 0,0:35:44.28,0:35:47.73,冬青黑体简体中文,,0,0,0,,通常是因为你想把它们放入数组或词典\N{\fs14}Usually because you want to put them in Array or a dictionary.
Dialogue: 0,0:35:47.73,0:35:51.52,冬青黑体简体中文,,0,0,0,,你不能将int放到数组中 你需要NSNumber对象\N{\fs14}So you can't put an int into an array; you need to have an NSNumber object.
Dialogue: 0,0:35:51.52,0:35:56.02,冬青黑体简体中文,,0,0,0,,你可以用类方法创建它们 例如numberWithInt\N{\fs14}You can create them with class methods like number with int --
Dialogue: 0,0:35:56.02,0:35:59.51,冬青黑体简体中文,,0,0,0,,这是NSNumber方法中的一个类函数\N{\fs14}that's a class number in a class method NSNumber --
Dialogue: 0,0:35:59.52,0:36:02.60,冬青黑体简体中文,,0,0,0,,你也可以使用@()\N{\fs14}or you can use at sign parenthesis.
Dialogue: 0,0:36:02.60,0:36:05.40,冬青黑体简体中文,,0,0,0,,我们已经看到过@[]用于数组\N{\fs14}So we already saw at sign square bracket for arrays,
Dialogue: 0,0:36:05.40,0:36:07.33,冬青黑体简体中文,,0,0,0,,这里还有@()\N{\fs14}there's also at sign parenthesis,
Dialogue: 0,0:36:07.33,0:36:10.84,冬青黑体简体中文,,0,0,0,,甚至在创建数字时还可以用@数字\N{\fs14}or even just at sign number if you want to create a number.
Dialogue: 0,0:36:10.84,0:36:11.89,冬青黑体简体中文,,0,0,0,,例如@3\N{\fs14}So you could say at sign three.
Dialogue: 0,0:36:11.89,0:36:13.83,冬青黑体简体中文,,0,0,0,,还可以有@3.2\N{\fs14}You could also say at sign 3.2,
Dialogue: 0,0:36:13.83,0:36:16.84,冬青黑体简体中文,,0,0,0,,这会创建一个NSNumber 包含这一原始类型\N{\fs14}and that would create an NSNumber that would contain that primitive type.
Dialogue: 0,0:36:16.84,0:36:19.69,冬青黑体简体中文,,0,0,0,,如果使用括号 那么你就可以在括号中\N{\fs14}If you put the parenthesis, then you could put things inside
Dialogue: 0,0:36:19.69,0:36:22.92,冬青黑体简体中文,,0,0,0,,调用返回原始类型的方法\N{\fs14}like calls to methods that return a primitive type,
Dialogue: 0,0:36:22.92,0:36:23.94,冬青黑体简体中文,,0,0,0,,或枚举\N{\fs14}or enums,
Dialogue: 0,0:36:23.94,0:36:25.22,冬青黑体简体中文,,0,0,0,,或任意你想放到这里的东西\N{\fs14}or anything you want in there --
Dialogue: 0,0:36:25.22,0:36:29.34,冬青黑体简体中文,,0,0,0,,任意计算得到原始类型的表达式都能放到括号内\N{\fs14}any expression that evaluates to a primitive type can be put inside of parenthesis.
Dialogue: 0,0:36:29.34,0:36:33.62,冬青黑体简体中文,,0,0,0,,你可以说@() 它会根据结果创建一个NSNumber\N{\fs14}You say at sign parenthesis and it will create an NSNumber with the result.
Dialogue: 0,0:36:35.03,0:36:38.00,冬青黑体简体中文,,0,0,0,,大家都理解了这种语法吗\N{\fs14}Everybody understand that syntax?
Dialogue: 0,0:36:38.00,0:36:43.67,冬青黑体简体中文,,0,0,0,,其它语言都有这种自动装箱\N{\fs14}Okay. So other languages kind of have this autoboxing kind of stuff in there.
Dialogue: 0,0:36:43.67,0:36:47.33,冬青黑体简体中文,,0,0,0,,NSValue 我不打算讲太多\N{\fs14}NSValue, I'm not going to talk too much about it.
Dialogue: 0,0:36:47.33,0:36:51.98,冬青黑体简体中文,,0,0,0,,这是一种封装比原始类型更复杂类型的方式\N{\fs14}It's essentially a way to encapsulate more complicated types than primitive types,
Dialogue: 0,0:36:51.98,0:36:54.97,冬青黑体简体中文,,0,0,0,,基本上也就是C struct\N{\fs14}so structs basically, C structs.
Dialogue: 0,0:36:54.97,0:36:57.55,冬青黑体简体中文,,0,0,0,,NSValue知道如何包装\N{\fs14}And NSValue knows how to wrap up
Dialogue: 0,0:36:57.55,0:37:00.26,冬青黑体简体中文,,0,0,0,,iOS中一些不同类型的struct\N{\fs14}a few different kinds of structs that are in iOS.
Dialogue: 0,0:37:00.26,0:37:03.14,冬青黑体简体中文,,0,0,0,,具体哪些你们可以参阅说明文档\N{\fs14}And you can go look at the documentations to see which ones.
Dialogue: 0,0:37:03.14,0:37:06.38,冬青黑体简体中文,,0,0,0,,这里我要简单提到的是一点是\N{\fs14}One thing I'm going to give you a little tip right here, okay,
Dialogue: 0,0:37:06.38,0:37:12.19,冬青黑体简体中文,,0,0,0,,有时将struct包装起来的好办法是将它转化为字符串\N{\fs14}sometimes a good way to wrap up a struct is to turn it into a string.
Dialogue: 0,0:37:12.19,0:37:13.74,冬青黑体简体中文,,0,0,0,,然后你可以把它作为字符串放入数组\N{\fs14}Then you can put it in the array as a string.
Dialogue: 0,0:37:13.74,0:37:16.84,冬青黑体简体中文,,0,0,0,,这很棒 可以在调试器中打印 可以很好地看到\N{\fs14}It's nice because you print it out in the debugger and you can see it really nicely.
Dialogue: 0,0:37:16.84,0:37:21.52,冬青黑体简体中文,,0,0,0,,然后还有办法将字符串转换为C struct\N{\fs14}And then there's ways to turn things from strings back into C structs.
Dialogue: 0,0:37:21.52,0:37:26.83,冬青黑体简体中文,,0,0,0,,iOS中有C函数能将大多数struct转化为字符串\N{\fs14}So there are C functions in iOS that turn most of the structs in iOS into strings
Dialogue: 0,0:37:26.83,0:37:29.71,冬青黑体简体中文,,0,0,0,,还有其它C函数将字符串转化回struct\N{\fs14}and then other C functions that turn the strings back into the structs.
Dialogue: 0,0:37:29.71,0:37:34.30,冬青黑体简体中文,,0,0,0,,NSValue… 我认为多数时候你们可以用字符串\N{\fs14}So NSValue -- I think most of the time you can use strings.
Dialogue: 0,0:37:34.30,0:37:36.46,冬青黑体简体中文,,0,0,0,,也许存储在NSValue中更高效\N{\fs14}It's probably more efficient to store something as an NSValue
Dialogue: 0,0:37:36.46,0:37:38.50,冬青黑体简体中文,,0,0,0,,不过还是那句话 不要过度优化\N{\fs14}but, again, don't overoptimize.
Dialogue: 0,0:37:38.50,0:37:43.48,冬青黑体简体中文,,0,0,0,,转化为字符串在使用时也很不错\N{\fs14}Turning into a string is just as performant in the case you're using it.
Dialogue: 0,0:37:43.48,0:37:47.46,冬青黑体简体中文,,0,0,0,,这是因为它是一个字符串 很容易处理\N{\fs14}It's nice because it's a string and it's easy to look at.
Dialogue: 0,0:37:48.16,0:37:50.38,冬青黑体简体中文,,0,0,0,,NSData是另一种Foundation类\N{\fs14}NSData is another Foundation class,
Dialogue: 0,0:37:50.38,0:37:51.63,冬青黑体简体中文,,0,0,0,,只是"二进制包"\N{\fs14}just a bag of bits.
Dialogue: 0,0:37:51.63,0:37:53.12,冬青黑体简体中文,,0,0,0,,我们将使用NSData\N{\fs14}And we're going to be using NSDatas.
Dialogue: 0,0:37:53.12,0:37:54.56,冬青黑体简体中文,,0,0,0,,以后讲到时我会进一步讲\N{\fs14}We'll talk about them more when we get to that.
Dialogue: 0,0:37:54.56,0:37:58.66,冬青黑体简体中文,,0,0,0,,简单说来 NSData不过是一些二进制数据\N{\fs14}But it's just basically a certain count of bytes, that's what NSData is.
Dialogue: 0,0:37:59.05,0:38:01.75,冬青黑体简体中文,,0,0,0,,NSDate是日期\N{\fs14}NSDate is a date, right?
Dialogue: 0,0:38:01.75,0:38:03.26,冬青黑体简体中文,,0,0,0,,它有一些内部表示\N{\fs14}It has some internal representation.
Dialogue: 0,0:38:03.26,0:38:05.36,冬青黑体简体中文,,0,0,0,,也许是UNIX表示\N{\fs14}It's probably the UNIX representation
Dialogue: 0,0:38:05.37,0:38:08.80,冬青黑体简体中文,,0,0,0,,如1970年以来的秒数 诸如此类\N{\fs14}like the number of seconds since 1970 or whatever it is.
Dialogue: 0,0:38:08.80,0:38:13.70,冬青黑体简体中文,,0,0,0,,NSDate可以这样考虑 如果你要在UI中加入日期\N{\fs14}One thing to think about with NSDates, if you're going to put a date in your UI,
Dialogue: 0,0:38:13.70,0:38:16.40,冬青黑体简体中文,,0,0,0,,你需要知道你在做什么\N{\fs14}you got to know what you're doing.
Dialogue: 0,0:38:16.40,0:38:18.01,冬青黑体简体中文,,0,0,0,,为什么呢\N{\fs14}Why is that?
Dialogue: 0,0:38:18.01,0:38:21.95,冬青黑体简体中文,,0,0,0,,这是因为日期在世界范围内差异很大\N{\fs14}That's because dates vary dramatically all around the world.
Dialogue: 0,0:38:21.95,0:38:24.31,冬青黑体简体中文,,0,0,0,,我讲的还不是在法国\N{\fs14}And I'm not just talking about in French, you know,
Dialogue: 0,0:38:24.31,0:38:26.70,冬青黑体简体中文,,0,0,0,,连月份名字都不同 要知道\N{\fs14}the month names are different, but you know,
Dialogue: 0,0:38:26.70,0:38:30.35,冬青黑体简体中文,,0,0,0,,甚至连月在前还是日在前 不同地方都会不同\N{\fs14}the order of whether the month comes first or the date comes first varies.
Dialogue: 0,0:38:30.35,0:38:32.12,冬青黑体简体中文,,0,0,0,,世界上有些地方\N{\fs14}Some places on earth,
Dialogue: 0,0:38:32.12,0:38:35.38,冬青黑体简体中文,,0,0,0,,使用的日历都跟我们不一样\N{\fs14}some locales don't even use the same calendar as we use.
Dialogue: 0,0:38:35.38,0:38:40.03,冬青黑体简体中文,,0,0,0,,所以iOS中有大量基础设施来处理这个\N{\fs14}So there is an enormous amount of infrastructure in iOS for dealing with this.
Dialogue: 0,0:38:40.03,0:38:41.76,冬青黑体简体中文,,0,0,0,,有NSCalendar这样的类\N{\fs14}Classes like NSCalendar,
Dialogue: 0,0:38:41.76,0:38:43.82,冬青黑体简体中文,,0,0,0,,有日期格式化器等等\N{\fs14}and date formatter, and things like that.
Dialogue: 0,0:38:43.82,0:38:47.89,冬青黑体简体中文,,0,0,0,,如果你要在UI中使用日期 请务必熟悉所有这些\N{\fs14}If you're going to put in your UI, familiarize yourself with all of that.
Dialogue: 0,0:38:47.89,0:38:50.85,冬青黑体简体中文,,0,0,0,,课堂上我显然没时间一一讲解\N{\fs14}I don't have time to go over it all in lecture unfortunately.
Dialogue: 0,0:38:50.85,0:38:53.11,冬青黑体简体中文,,0,0,0,,但你需要知道 有些东西你需要知道\N{\fs14}But you just need to know that there's something you need to know.
Dialogue: 0,0:38:53.11,0:38:58.21,冬青黑体简体中文,,0,0,0,,你不能在UI中仅仅说NSDate description\N{\fs14}You can't just say NSDate description and put it in the UI.
Dialogue: 0,0:38:58.21,0:39:01.30,冬青黑体简体中文,,0,0,0,,日期比这要复杂很多\N{\fs14}Dates are a little bit complicated.
Dialogue: 0,0:39:01.30,0:39:05.12,冬青黑体简体中文,,0,0,0,,NSSet是对象的无序集合\N{\fs14}There's NSSet, which a set is an unordered collection of objects,
Dialogue: 0,0:39:05.12,0:39:06.51,冬青黑体简体中文,,0,0,0,,对象都是唯一的\N{\fs14}so the objects are unique.
Dialogue: 0,0:39:06.51,0:39:11.46,冬青黑体简体中文,,0,0,0,,就算你把相同对象放进去两次 它也只会存在一次\N{\fs14}So you put the same objects in there twice, it only goes in there once.
Dialogue: 0,0:39:11.46,0:39:14.61,冬青黑体简体中文,,0,0,0,,NSSet就是一般意义上的集合\N{\fs14}So sets are what you would think of in term of sets.
Dialogue: 0,0:39:14.61,0:39:18.54,冬青黑体简体中文,,0,0,0,,然后还有有序集 介于NSSet和数组之间\N{\fs14}And there's actually an ordered set, which is like a cross between the set and an array.
Dialogue: 0,0:39:18.54,0:39:19.63,冬青黑体简体中文,,0,0,0,,你们可以自己去查\N{\fs14}And you can look those up.
Dialogue: 0,0:39:19.63,0:39:22.95,冬青黑体简体中文,,0,0,0,,这些你们可能用不着 NSSet你们可能会用到\N{\fs14}You're not going to need those probably -- well, you might need set.
Dialogue: 0,0:39:22.95,0:39:25.15,冬青黑体简体中文,,0,0,0,,NSSet很好\N{\fs14}Set is nice because you can do things if you have --
Dialogue: 0,0:39:25.15,0:39:27.85,冬青黑体简体中文,,0,0,0,,很便于告诉你集合中是否有什么\N{\fs14}set is very good at telling you whether something's in the set.
Dialogue: 0,0:39:27.85,0:39:31.29,冬青黑体简体中文,,0,0,0,,而数组 如果数组中有一千个元素\N{\fs14}Whereas an array, if you had an array of a thousand things,
Dialogue: 0,0:39:31.29,0:39:33.34,冬青黑体简体中文,,0,0,0,,数组可能需要进行二分查找\N{\fs14}the array might have to do some binary searching or --
Dialogue: 0,0:39:33.34,0:39:35.43,冬青黑体简体中文,,0,0,0,,二分查找可能都不行 因为它不知道顺序\N{\fs14}well, I guess it can't even binary search because it doesn't know the order.
Dialogue: 0,0:39:35.43,0:39:38.76,冬青黑体简体中文,,0,0,0,,它会在这里面到处找 很难找到东西\N{\fs14}So it's got to look around in there. It's hard for it to find things.
Dialogue: 0,0:39:38.76,0:39:42.24,冬青黑体简体中文,,0,0,0,,但NSSet经过了hash处理 效率很高\N{\fs14}But a set is probably hashed and high efficiency.
Dialogue: 0,0:39:42.24,0:39:44.33,冬青黑体简体中文,,0,0,0,,就算集合中有一万个对象\N{\fs14}It can tell you if you had a set of ten thousand objects
Dialogue: 0,0:39:44.33,0:39:46.18,冬青黑体简体中文,,0,0,0,,你问它 这个对象在里面吗\N{\fs14}and you ask it, "Is this object in there?"
Dialogue: 0,0:39:46.18,0:39:48.17,冬青黑体简体中文,,0,0,0,,它会很高效地告诉你\N{\fs14}it could probably tell you really efficiently.
Dialogue: 0,0:39:48.17,0:39:52.59,冬青黑体简体中文,,0,0,0,,有时NSSet对比数组还是有些价值的\N{\fs14}So there are some values sometimes sets versus Array.
Dialogue: 0,0:39:52.59,0:39:54.91,冬青黑体简体中文,,0,0,0,,好 字典\N{\fs14}Okay. Dictionary.
Dialogue: 0,0:39:54.91,0:39:59.03,冬青黑体简体中文,,0,0,0,,这是第二重要的集合类 可能仅次于数组\N{\fs14}This is the second most important collection class behind Array probably.
Dialogue: 0,0:39:59.03,0:40:03.66,冬青黑体简体中文,,0,0,0,,它是键值对的不可变集合\N{\fs14}It's an immutable collection of key value pairs.
Dialogue: 0,0:40:03.66,0:40:04.83,冬青黑体简体中文,,0,0,0,,类似hash表\N{\fs14}It's like a hash table.
Dialogue: 0,0:40:04.83,0:40:09.55,冬青黑体简体中文,,0,0,0,,所有键和值都是强存储的\N{\fs14}All the keys and values are held onto strongly.
Dialogue: 0,0:40:09.55,0:40:13.81,冬青黑体简体中文,,0,0,0,,如果它们在那里作为键或值 那么它们就在堆中\N{\fs14}So if they're in there as a key or a value, then they're in the heap.
Dialogue: 0,0:40:13.81,0:40:16.31,冬青黑体简体中文,,0,0,0,,只要字典在堆中 它们就在\N{\fs14}And they stay in there as long as the dictionary stays in the heap.
Dialogue: 0,0:40:16.31,0:40:19.16,冬青黑体简体中文,,0,0,0,,键和值显然都是对象\N{\fs14}The keys and values, obviously, are both objects.
Dialogue: 0,0:40:19.16,0:40:22.73,冬青黑体简体中文,,0,0,0,,等下我会讲到键要怎样才能成为键\N{\fs14}We'll talk about what the key has to do to be a key in a second here.
Dialogue: 0,0:40:22.73,0:40:26.36,冬青黑体简体中文,,0,0,0,,不可变NSDictionary的创建方法通常是\N{\fs14}You usually create immutable NSDictionaries using another
Dialogue: 0,0:40:26.36,0:40:30.07,冬青黑体简体中文,,0,0,0,,另一种@语法 即@花括号\N{\fs14}at sign syntax called "at sign curly brace."
Dialogue: 0,0:40:30.07,0:40:34.16,冬青黑体简体中文,,0,0,0,,形如@ 花括号 键:值 逗号\N{\fs14}Okay. So it's at sign curly brace, key colon value, comma,
Dialogue: 0,0:40:34.16,0:40:37.85,冬青黑体简体中文,,0,0,0,,键:值 逗号 键:值 反花括号\N{\fs14}key colon value, comma, key colon value, end curly brace.
Dialogue: 0,0:40:37.85,0:40:39.90,冬青黑体简体中文,,0,0,0,,这类似于数组的@[]\N{\fs14}So this is kind of like the at sign square brackets
Dialogue: 0,0:40:39.90,0:40:42.32,冬青黑体简体中文,,0,0,0,,以及NSNumber的@()\N{\fs14}for arrays or the at sign parenthesis for NSNumbers.
Dialogue: 0,0:40:42.32,0:40:46.38,冬青黑体简体中文,,0,0,0,,这是@版本的NSDictionary\N{\fs14}This is NSDictionary's version of that.
Dialogue: 0,0:40:46.38,0:40:49.29,冬青黑体简体中文,,0,0,0,,你可以在字典中查东西\N{\fs14}You look up things inside a dictionary.
Dialogue: 0,0:40:49.29,0:40:51.61,冬青黑体简体中文,,0,0,0,,显然你可以用objectForKey\N{\fs14}You can obviously do object for key.
Dialogue: 0,0:40:51.61,0:40:54.42,冬青黑体简体中文,,0,0,0,,这是通过键找值的很好方法\N{\fs14}That's a nice method for looking the value up by key.
Dialogue: 0,0:40:54.42,0:40:56.27,冬青黑体简体中文,,0,0,0,,但你也可以使用方括号\N{\fs14}But you can also use square brackets
Dialogue: 0,0:40:56.27,0:40:58.81,冬青黑体简体中文,,0,0,0,,类似于在数组中查找\N{\fs14}that looks kind of like looking up an array.
Dialogue: 0,0:40:58.81,0:41:01.57,冬青黑体简体中文,,0,0,0,,例如幻灯片中的这个颜色字典colors\N{\fs14}So if I had that colors dictionary that's showing right there
Dialogue: 0,0:41:01.57,0:41:04.77,冬青黑体简体中文,,0,0,0,,字符串有绿 蓝 红\N{\fs14}and I had a string that was either green, or blue, or red,
Dialogue: 0,0:41:04.77,0:41:09.16,冬青黑体简体中文,,0,0,0,,想要查找 我可以说 colors[colorString]\N{\fs14}and I wanted to look it up, I can just say colors, open square bracket, the color string.
Dialogue: 0,0:41:09.16,0:41:10.88,冬青黑体简体中文,,0,0,0,,它会查找这个字符串\N{\fs14}And it will look up that string.
Dialogue: 0,0:41:10.88,0:41:14.58,冬青黑体简体中文,,0,0,0,,如果没有这样的键 它会返回nil\N{\fs14}It would return nil if there's no such key in there.
Dialogue: 0,0:41:14.58,0:41:18.03,冬青黑体简体中文,,0,0,0,,如果存在 它会返回实际UIColor值\N{\fs14}And it will return the value, the actual UI color.
Dialogue: 0,0:41:18.03,0:41:20.96,冬青黑体简体中文,,0,0,0,,过几张幻灯片我会讲到UIColor\N{\fs14}So we're going to talk about UI colors in a couple slides.
Dialogue: 0,0:41:20.96,0:41:28.71,冬青黑体简体中文,,0,0,0,,这也是访问事物的很酷语法\N{\fs14}So this is also really cool UI -- or syntax rather -- for accessing stuff.
Dialogue: 0,0:41:28.71,0:41:31.06,冬青黑体简体中文,,0,0,0,,这些@方括号 @花括号\N{\fs14}These at sign square brackets, at sign curly brace,
Dialogue: 0,0:41:31.06,0:41:35.42,冬青黑体简体中文,,0,0,0,,@圆括号 是Objective-C中的重大改进\N{\fs14}at sign parenthesis -- big improvement to Objective-C.
Dialogue: 0,0:41:35.42,0:41:38.58,冬青黑体简体中文,,0,0,0,,当然 你也可以看其中有多少对象\N{\fs14}Of course, you can see how many objects in there.
Dialogue: 0,0:41:38.58,0:41:40.52,冬青黑体简体中文,,0,0,0,,你可以用objectForKey来得到它\N{\fs14}You can do object for key to get it.
Dialogue: 0,0:41:40.52,0:41:43.71,冬青黑体简体中文,,0,0,0,,键需要实现hash和isEqual\N{\fs14}Key has to implement hash and is equal, right?
Dialogue: 0,0:41:43.71,0:41:45.18,冬青黑体简体中文,,0,0,0,,这是一张hash表\N{\fs14}It's a hash table.
Dialogue: 0,0:41:45.18,0:41:48.37,冬青黑体简体中文,,0,0,0,,你需要能够为键实现hash 从而能够有效查找\N{\fs14}You have to be able to hash the key so we can have an efficient lookup.
Dialogue: 0,0:41:48.37,0:41:50.62,冬青黑体简体中文,,0,0,0,,但两个键可能hash到相同事物\N{\fs14}But then two things might hash to the same thing,
Dialogue: 0,0:41:50.62,0:41:52.82,冬青黑体简体中文,,0,0,0,,所以你需要isEqual来检验\N{\fs14}so you have to have is equal determine whether
Dialogue: 0,0:41:52.82,0:41:56.18,冬青黑体简体中文,,0,0,0,,hash到相同事物的两个对象是否相等\N{\fs14}two objects that hash to the same thing are actually equal.
Dialogue: 0,0:41:56.18,0:42:00.37,冬青黑体简体中文,,0,0,0,,NSObject对这个的实现很糟糕\N{\fs14}NSObject implements this very poorly.
Dialogue: 0,0:42:00.37,0:42:06.14,冬青黑体简体中文,,0,0,0,,千万别把一个通用对象 或你创建的某种对象的子类\N{\fs14}So you would never use a generic object or some subclass of object that you've created.
Dialogue: 0,0:42:06.14,0:42:07.73,冬青黑体简体中文,,0,0,0,,用作键\N{\fs14}You would never use it as a key.
Dialogue: 0,0:42:07.75,0:42:10.64,冬青黑体简体中文,,0,0,0,,你也许可以使用指针hash\N{\fs14}You're probably going to do pointer hashing.
Dialogue: 0,0:42:10.64,0:42:13.19,冬青黑体简体中文,,0,0,0,,只在对象总是唯一时这才能行\N{\fs14}So it would only do it if your objects are always unique.
Dialogue: 0,0:42:13.19,0:42:17.48,冬青黑体简体中文,,0,0,0,,堆中两个相同对象不会具有不同指针\N{\fs14}In the heap there's never two objects that are the same that have different pointers.
Dialogue: 0,0:42:17.48,0:42:20.73,冬青黑体简体中文,,0,0,0,,字符串在NSDictionary中是很好的键\N{\fs14}Strings are excellent keys in NSDictionaries.
Dialogue: 0,0:42:20.73,0:42:26.14,冬青黑体简体中文,,0,0,0,,我可以说 字典中的键90%的时候都是字符串\N{\fs14}And so I would say strings are the key in a dictionary 90 percent of the time.
Dialogue: 0,0:42:26.14,0:42:27.41,冬青黑体简体中文,,0,0,0,,它们很好\N{\fs14}They're very good.
Dialogue: 0,0:42:27.41,0:42:28.75,冬青黑体简体中文,,0,0,0,,hash很好\N{\fs14}They hash really well.
Dialogue: 0,0:42:28.75,0:42:32.97,冬青黑体简体中文,,0,0,0,,它们很快 对isEqual很有利 等等\N{\fs14}They're very fast and do is equal, etc. Okay?
Dialogue: 0,0:42:32.97,0:42:35.37,冬青黑体简体中文,,0,0,0,,当然 这是不可变的\N{\fs14}Of course, immutable, again,
Dialogue: 0,0:42:35.37,0:42:38.22,冬青黑体简体中文,,0,0,0,,有时我们希望将事物加到字典中\N{\fs14}we'd like to sometimes add things to our dictionaries.
Dialogue: 0,0:42:38.22,0:42:40.63,冬青黑体简体中文,,0,0,0,,所以我们有可变版本的NSMutableDictionary\N{\fs14}So we have a mutable version, NSMutable dictionary.
Dialogue: 0,0:42:40.63,0:42:42.45,冬青黑体简体中文,,0,0,0,,通常用alloc init创建\N{\fs14}Usually create it with alloc init.
Dialogue: 0,0:42:42.47,0:42:44.15,冬青黑体简体中文,,0,0,0,,字典有的它都有\N{\fs14}It has all the things of a dictionary,
Dialogue: 0,0:42:44.15,0:42:46.06,冬青黑体简体中文,,0,0,0,,此外 它还有setObject: forKey:\N{\fs14}plus it has set object for key --
Dialogue: 0,0:42:46.06,0:42:48.09,冬青黑体简体中文,,0,0,0,,来添加一个键值对\N{\fs14}that adds a key value pair --
Dialogue: 0,0:42:48.09,0:42:52.40,冬青黑体简体中文,,0,0,0,,你还可以删掉对象 从另一个字典中加入条目 等等\N{\fs14}and you can remove objects, add entries from another dictionary, etc., etc.
Dialogue: 0,0:42:52.40,0:42:54.77,冬青黑体简体中文,,0,0,0,,循环遍历字典是这样的\N{\fs14}Looping through a dictionary looks like this.
Dialogue: 0,0:42:54.77,0:42:57.58,冬青黑体简体中文,,0,0,0,,使用for id key in 字典\N{\fs14}You do for ID key in the dictionary.
Dialogue: 0,0:42:57.58,0:43:02.80,冬青黑体简体中文,,0,0,0,,对字典使用for in结构 都是遍历键\N{\fs14}So basically when you do for in on a dictionary, you're looping through the keys.
Dialogue: 0,0:43:02.80,0:43:04.69,冬青黑体简体中文,,0,0,0,,当然 循环中间就简单了\N{\fs14}Now, of course, inside it's really easy.
Dialogue: 0,0:43:04.69,0:43:07.15,冬青黑体简体中文,,0,0,0,,你只需要 value等于objectForKey\N{\fs14}You just say, "Value equals object for key,"
Dialogue: 0,0:43:07.15,0:43:10.60,冬青黑体简体中文,,0,0,0,,或者也可以使用方括号表示法来获得值\N{\fs14}or even use the square brackets notation to get the value.
Dialogue: 0,0:43:10.60,0:43:12.95,冬青黑体简体中文,,0,0,0,,这也就循环遍历了值\N{\fs14}So you're kind of looping through the values, too,
Dialogue: 0,0:43:12.95,0:43:15.30,冬青黑体简体中文,,0,0,0,,只要你的hash非常有效\N{\fs14}as long as your hashing is efficient,
Dialogue: 0,0:43:15.30,0:43:17.79,冬青黑体简体中文,,0,0,0,,如果是字符串确实也会很有效\N{\fs14}which it is if they're strings. This is [inaudible].
Dialogue: 0,0:43:17.81,0:43:20.86,冬青黑体简体中文,,0,0,0,,你还可以让字典\N{\fs14}It is possible to ask a dictionary,
Dialogue: 0,0:43:20.86,0:43:23.64,冬青黑体简体中文,,0,0,0,,将所有值作为数组给你\N{\fs14}"Give me all your values as an array"?
Dialogue: 0,0:43:23.64,0:43:26.42,冬青黑体简体中文,,0,0,0,,然后你可以在数组中使用for in循环\N{\fs14}And then you could for in through that array.
Dialogue: 0,0:43:26.42,0:43:28.66,冬青黑体简体中文,,0,0,0,,那是否比这更有效\N{\fs14}And whether that's more efficient than doing this probably
Dialogue: 0,0:43:28.66,0:43:31.39,冬青黑体简体中文,,0,0,0,,取决于字典的规模等等 别太担心这些\N{\fs14}depends on the size of your dictionary, etc., etc. Don't worry about it.
Dialogue: 0,0:43:31.39,0:43:32.66,冬青黑体简体中文,,0,0,0,,这门课中这不要紧\N{\fs14}It's never going to be an issue in this class.
Dialogue: 0,0:43:32.66,0:43:36.12,冬青黑体简体中文,,0,0,0,,我们的字典中不会有成千上万的对象\N{\fs14}We're not going to have dictionaries of thousands of objects.
Dialogue: 0,0:43:38.29,0:43:42.53,冬青黑体简体中文,,0,0,0,,我要讲的下一点不是类 不是语法\N{\fs14}Next thing I'm going to talk about is not a class, or syntax,
Dialogue: 0,0:43:42.53,0:43:46.17,冬青黑体简体中文,,0,0,0,,而是一个短语 属性列表\N{\fs14}or whatever; it's a word, a phrase -- property list.
Dialogue: 0,0:43:46.17,0:43:48.10,冬青黑体简体中文,,0,0,0,,我将定义这个术语\N{\fs14}And I'm just going to define this term.
Dialogue: 0,0:43:48.10,0:43:50.40,冬青黑体简体中文,,0,0,0,,你们需要知道属性列表是什么意思\N{\fs14}You need to know what this term means, property list.
Dialogue: 0,0:43:50.40,0:43:54.56,冬青黑体简体中文,,0,0,0,,属性列表的意思是 集合的集合\N{\fs14}A property list means a "collection of collections."
Dialogue: 0,0:43:54.56,0:43:56.15,冬青黑体简体中文,,0,0,0,,什么是集合\N{\fs14}What's a collection?
Dialogue: 0,0:43:56.15,0:43:58.43,冬青黑体简体中文,,0,0,0,,也就是NSArray 字典 甚至字符串\N{\fs14}NSArray, dictionary, even string,
Dialogue: 0,0:43:58.43,0:43:59.67,冬青黑体简体中文,,0,0,0,,NSData NSNumber\N{\fs14}NSData, NSNumber --
Dialogue: 0,0:43:59.67,0:44:02.21,冬青黑体简体中文,,0,0,0,,这些都是简单的集合\N{\fs14}those are all simple collections if you want it think of them
Dialogue: 0,0:44:02.21,0:44:05.48,冬青黑体简体中文,,0,0,0,,或者可以把它们看成集合的叶节点\N{\fs14}that way or they're the leaf nodes of collections.
Dialogue: 0,0:44:05.48,0:44:08.38,冬青黑体简体中文,,0,0,0,,任意对象图 只要其中只有数组\N{\fs14}So if you have any object graph that just has arrays
Dialogue: 0,0:44:08.38,0:44:11.14,冬青黑体简体中文,,0,0,0,,字典 数字 字符串 日期和数据这些\N{\fs14}and dictionaries, numbers, strings, dates, and datas,
Dialogue: 0,0:44:11.14,0:44:13.41,冬青黑体简体中文,,0,0,0,,那它就是属性列表了\N{\fs14}then it's called a "property list."
Dialogue: 0,0:44:13.41,0:44:17.38,冬青黑体简体中文,,0,0,0,,例如一个字符串数组就是属性列表\N{\fs14}So just for an example, if you had an array of strings, that's a property list;
Dialogue: 0,0:44:17.38,0:44:19.65,冬青黑体简体中文,,0,0,0,,数组的数组\N{\fs14}an array of arrays,
Dialogue: 0,0:44:19.65,0:44:23.54,冬青黑体简体中文,,0,0,0,,而这些数组包含属性列表 那它也是属性列表\N{\fs14}and those arrays contain property lists, it's the property list.
Dialogue: 0,0:44:23.54,0:44:24.93,冬青黑体简体中文,,0,0,0,,任意的图\N{\fs14}So any arbitrary graph.
Dialogue: 0,0:44:24.93,0:44:27.36,冬青黑体简体中文,,0,0,0,,只要其中有这些对象\N{\fs14}But as soon as you have any object in there
Dialogue: 0,0:44:27.36,0:44:30.78,冬青黑体简体中文,,0,0,0,,而且对象属于这些东西或者它们的可变版本\N{\fs14}that's not one of these things or they're mutable versions --
Dialogue: 0,0:44:30.78,0:44:32.51,冬青黑体简体中文,,0,0,0,,可变的这些也是允许的\N{\fs14}that's allowed, too; so you can have
Dialogue: 0,0:44:32.51,0:44:35.10,冬青黑体简体中文,,0,0,0,,例如NSMutableString或NSMutableArray\N{\fs14}NSMutableStrings or NSMutableArrays in there --
Dialogue: 0,0:44:35.10,0:44:37.54,冬青黑体简体中文,,0,0,0,,这就是属性列表了\N{\fs14}then it's a property list.
Dialogue: 0,0:44:37.54,0:44:40.69,冬青黑体简体中文,,0,0,0,,字典是属性列表的条件是 它所有的键\N{\fs14}A dictionary is only a property list if all of its keys
Dialogue: 0,0:44:40.69,0:44:43.74,冬青黑体简体中文,,0,0,0,,及所有值都是属性列表\N{\fs14}and all of its values are property lists.
Dialogue: 0,0:44:43.74,0:44:46.28,冬青黑体简体中文,,0,0,0,,例如键是字符串 值是数组或其它属性列表的字典\N{\fs14}So a dictionary that keys are strings,
Dialogue: 0,0:44:46.28,0:44:50.17,冬青黑体简体中文,,0,0,0,,例如键是字符串 值是数组或其它属性列表的字典\N{\fs14}and values are arrays, or other dictionaries of property lists,
Dialogue: 0,0:44:50.17,0:44:52.10,冬青黑体简体中文,,0,0,0,,将也是属性列表\N{\fs14}that would be a property list.
Dialogue: 0,0:44:52.10,0:44:54.31,冬青黑体简体中文,,0,0,0,,为什么要定义这个说法呢\N{\fs14}Why do we define this term?
Dialogue: 0,0:44:54.31,0:44:57.61,冬青黑体简体中文,,0,0,0,,因为iOS中有一系列API\N{\fs14}Because there's a bunch of API throughout iOS that you're going
Dialogue: 0,0:44:57.61,0:45:01.19,冬青黑体简体中文,,0,0,0,,将属性列表作为参数\N{\fs14}to see that takes a property list as the argument.
Dialogue: 0,0:45:01.19,0:45:03.99,冬青黑体简体中文,,0,0,0,,但属性列表只是我们定义的一个短语\N{\fs14}But property list is only a phrase we define,
Dialogue: 0,0:45:03.99,0:45:07.84,冬青黑体简体中文,,0,0,0,,其类型可能用的是id\N{\fs14}so it's probably going to take an ID. It's going to take an ID.
Dialogue: 0,0:45:07.84,0:45:09.97,冬青黑体简体中文,,0,0,0,,也可能是NSArray或NSDictionary\N{\fs14}It might take an NSArray or an NSDictionary,
Dialogue: 0,0:45:09.97,0:45:11.21,冬青黑体简体中文,,0,0,0,,取决于API\N{\fs14}depending on the API.
Dialogue: 0,0:45:11.21,0:45:15.10,冬青黑体简体中文,,0,0,0,,不过在说明文档中 它说的基本上是\N{\fs14}But it's basically saying in its documentation,
Dialogue: 0,0:45:15.10,0:45:17.28,冬青黑体简体中文,,0,0,0,,这个的参数是属性列表\N{\fs14}"The argument to this is a property list."
Dialogue: 0,0:45:17.28,0:45:20.40,冬青黑体简体中文,,0,0,0,,如果是数组 那就是属性列表的数组\N{\fs14}So even if it's an array, it's got to be an array of property lists.
Dialogue: 0,0:45:20.40,0:45:21.62,冬青黑体简体中文,,0,0,0,,如果是字典\N{\fs14}If it's a dictionary, it's got to be
Dialogue: 0,0:45:21.62,0:45:23.77,冬青黑体简体中文,,0,0,0,,那就是键和值只有属性列表的字典\N{\fs14}a dictionary that has only property lists with keys and values.
Dialogue: 0,0:45:23.77,0:45:27.84,冬青黑体简体中文,,0,0,0,,如果是id 它将是数组 字典 字符串或数字\N{\fs14}If it's an ID, it's got to be an array, or a dictionary, or a string, or number.
Dialogue: 0,0:45:27.84,0:45:30.17,冬青黑体简体中文,,0,0,0,,这必须是一个属性列表\N{\fs14}You know what I mean? It's got to be a property list.
Dialogue: 0,0:45:30.19,0:45:31.28,冬青黑体简体中文,,0,0,0,,能理解吗\N{\fs14}Make sense?
Dialogue: 0,0:45:31.30,0:45:35.89,冬青黑体简体中文,,0,0,0,,实际上 我要讲一个只作用于属性列表的类\N{\fs14}And in fact, I'm going to show you one class that only operates on property lists,
Dialogue: 0,0:45:35.90,0:45:37.83,冬青黑体简体中文,,0,0,0,,也就是NSUserDefaults\N{\fs14}which is NSUserDefaults.
Dialogue: 0,0:45:37.83,0:45:42.48,冬青黑体简体中文,,0,0,0,,NSUserDefaults是一种共享字典\N{\fs14}So NSUserDefaults is this one shared dictionary essentially
Dialogue: 0,0:45:42.48,0:45:48.22,冬青黑体简体中文,,0,0,0,,这甚至在应用程序启动和退出时仍然持续存在\N{\fs14}that persists, even across application launching. Exiting and launching.
Dialogue: 0,0:45:48.22,0:45:52.62,冬青黑体简体中文,,0,0,0,,它就像是一个永久的NSDictionary\N{\fs14}So it's like a permanent NSDictionary kind of.
Dialogue: 0,0:45:52.62,0:45:55.60,冬青黑体简体中文,,0,0,0,,NSUserDefaults数据库中存储的一切\N{\fs14}Everything that's stored in an NSUserDefault database
Dialogue: 0,0:45:55.60,0:45:57.35,冬青黑体简体中文,,0,0,0,,都必须是一个属性列表\N{\fs14}has to be a property list.
Dialogue: 0,0:45:57.35,0:46:01.01,冬青黑体简体中文,,0,0,0,,不过它并非一个完全的数据库\N{\fs14}So it's not a full-on database, though.
Dialogue: 0,0:46:01.01,0:46:02.79,冬青黑体简体中文,,0,0,0,,它很小\N{\fs14}It's pretty small.
Dialogue: 0,0:46:02.79,0:46:04.83,冬青黑体简体中文,,0,0,0,,性能不是很好\N{\fs14}It's not really high performance.
Dialogue: 0,0:46:04.83,0:46:07.98,冬青黑体简体中文,,0,0,0,,你只能将小东西存放到这里\N{\fs14}So you only want to store small things in there.
Dialogue: 0,0:46:07.98,0:46:10.73,冬青黑体简体中文,,0,0,0,,不要存放大型图片这样的东西\N{\fs14}Okay. You don't want to be storing huge images or anything
Dialogue: 0,0:46:10.73,0:46:13.90,冬青黑体简体中文,,0,0,0,,将它们转化为NSData 然后存储\N{\fs14}like that, you know, turning them into NSDatas or something and storing them.
Dialogue: 0,0:46:13.90,0:46:14.90,冬青黑体简体中文,,0,0,0,,不要这样做\N{\fs14}You really don't want to do that.
Dialogue: 0,0:46:14.90,0:46:19.78,冬青黑体简体中文,,0,0,0,,小字符串 字符串数组 NSNumber\N{\fs14}Small strings, and arrays of strings, and NSNumbers,
Dialogue: 0,0:46:19.78,0:46:24.12,冬青黑体简体中文,,0,0,0,,日期 这些东西是可以的\N{\fs14}dates maybe -- those kind of things is okay.
Dialogue: 0,0:46:24.12,0:46:25.62,冬青黑体简体中文,,0,0,0,,其API\N{\fs14}Its API.
Dialogue: 0,0:46:25.62,0:46:29.28,冬青黑体简体中文,,0,0,0,,要访问它 你要调用NSUserDefaults的这个类方法\N{\fs14}To access it, you call this class method on NSUserDefaults
Dialogue: 0,0:46:29.28,0:46:30.64,冬青黑体简体中文,,0,0,0,,叫standardUserDefaults\N{\fs14}called "standard user defaults."
Dialogue: 0,0:46:30.64,0:46:34.36,冬青黑体简体中文,,0,0,0,,这会给你整个应用中共享的一个实例\N{\fs14}And that will give you an instance that is shared across your entire application.
Dialogue: 0,0:46:34.36,0:46:35.71,冬青黑体简体中文,,0,0,0,,这是全局的\N{\fs14}It's like a global.
Dialogue: 0,0:46:35.71,0:46:38.17,冬青黑体简体中文,,0,0,0,,这种东西只有一个\N{\fs14}There's only one of these things.
Dialogue: 0,0:46:38.17,0:46:42.77,冬青黑体简体中文,,0,0,0,,你将消息发送给它 例如setArray: forKey:\N{\fs14}And you send messages to it like this set array for key.
Dialogue: 0,0:46:42.77,0:46:45.65,冬青黑体简体中文,,0,0,0,,还有setDouble: forKey:\N{\fs14}There's also set double for key,
Dialogue: 0,0:46:45.65,0:46:47.14,冬青黑体简体中文,,0,0,0,,setObject: forKey:\N{\fs14}set object for key.
Dialogue: 0,0:46:47.14,0:46:49.55,冬青黑体简体中文,,0,0,0,,这一对象需要是属性列表\N{\fs14}That object would have to be a property list.
Dialogue: 0,0:46:49.55,0:46:51.43,冬青黑体简体中文,,0,0,0,,这就像是一个字典\N{\fs14}So it's kind of like a dictionary
Dialogue: 0,0:46:51.43,0:46:54.17,冬青黑体简体中文,,0,0,0,,但它还有这些额外方法 如setDouble: forKey:\N{\fs14}but it has these extra method like set double for key
Dialogue: 0,0:46:54.17,0:46:56.93,冬青黑体简体中文,,0,0,0,,这样你就能够存储原始类型到这里\N{\fs14}so that you can store primitive types in there
Dialogue: 0,0:46:56.93,0:46:59.11,冬青黑体简体中文,,0,0,0,,无需先将它们转化为NSNumber\N{\fs14}without having to turn them into NSNumbers first.
Dialogue: 0,0:46:59.11,0:47:01.82,冬青黑体简体中文,,0,0,0,,这里可以说是得到类型检查\N{\fs14}You know, it kind of gets the type checking of it
Dialogue: 0,0:47:01.82,0:47:03.89,冬青黑体简体中文,,0,0,0,,而不只是setObject: forKey:\N{\fs14}versus just set object for key where
Dialogue: 0,0:47:03.89,0:47:07.04,冬青黑体简体中文,,0,0,0,,不知道类型是不是double 等等\N{\fs14}it doesn't know whether that's a double or not, etc.
Dialogue: 0,0:47:07.04,0:47:09.53,冬青黑体简体中文,,0,0,0,,有的这种东西 因为现在我们有了自动装箱\N{\fs14}And some of this -- because now we have the autoboxing,
Dialogue: 0,0:47:09.53,0:47:11.74,冬青黑体简体中文,,0,0,0,,你们知道 @括号这些东西\N{\fs14}you know, the at sign parenthesis business --
Dialogue: 0,0:47:11.74,0:47:14.88,冬青黑体简体中文,,0,0,0,,有的API 我们不再那么需要\N{\fs14}some of this API we don't really need that much anymore.
Dialogue: 0,0:47:14.88,0:47:17.67,冬青黑体简体中文,,0,0,0,,但它仍然在这里 请讲\N{\fs14}But it's all still in there. Yeah?
Dialogue: 0,0:47:24.13,0:47:26.38,冬青黑体简体中文,,0,0,0,,问题是 属性列表这个概念\N{\fs14}Yeah. So the question is: Does the property list idea have
Dialogue: 0,0:47:26.38,0:47:28.92,冬青黑体简体中文,,0,0,0,,是否往下逐步应用到子内容\N{\fs14}to cascade down through all of the sub things?
Dialogue: 0,0:47:28.92,0:47:30.30,冬青黑体简体中文,,0,0,0,,答案是肯定的\N{\fs14}And the answer is yes.
Dialogue: 0,0:47:30.30,0:47:32.21,冬青黑体简体中文,,0,0,0,,要成为属性列表\N{\fs14}A property list, for it to be a property list,
Dialogue: 0,0:47:32.21,0:47:35.99,冬青黑体简体中文,,0,0,0,,整个对象图中的一切都需要是属性列表\N{\fs14}everything in the entire object graph has to be a property list.
Dialogue: 0,0:47:35.99,0:47:37.17,冬青黑体简体中文,,0,0,0,,一直往下\N{\fs14}All the way down.
Dialogue: 0,0:47:37.17,0:47:39.09,冬青黑体简体中文,,0,0,0,,没有例外\N{\fs14}No exceptions.
Dialogue: 0,0:47:39.09,0:47:41.88,冬青黑体简体中文,,0,0,0,,如果你要调用setObject: forKey:这些\N{\fs14}And if you were to, for example, call set object for key
Dialogue: 0,0:47:41.88,0:47:46.38,冬青黑体简体中文,,0,0,0,,你将它往下传递到一个叶节点 它是Card\N{\fs14}and you passed it something that somewhere down a leaf node was a card, right,
Dialogue: 0,0:47:46.38,0:47:48.34,冬青黑体简体中文,,0,0,0,,或某种非属性列表的东西\N{\fs14}or some nonproperty list thing,
Dialogue: 0,0:47:48.34,0:47:51.15,冬青黑体简体中文,,0,0,0,,这个方法会引发异常 说\N{\fs14}this method would raise an exception and say,
Dialogue: 0,0:47:51.15,0:47:53.63,冬青黑体简体中文,,0,0,0,,这不是属性列表 这是在运行时\N{\fs14}"That's not a property list," okay, at runtime.
Dialogue: 0,0:47:53.63,0:47:55.87,冬青黑体简体中文,,0,0,0,,这会让程序崩溃\N{\fs14}So it would crash your program.
Dialogue: 0,0:47:57.19,0:47:58.91,冬青黑体简体中文,,0,0,0,,还要记住一点\N{\fs14}The other thing to remember, though,
Dialogue: 0,0:47:58.91,0:48:01.55,冬青黑体简体中文,,0,0,0,,一旦得到这种standardUserDefaults实例\N{\fs14}is once you've gotten this standard user default instance
Dialogue: 0,0:48:01.55,0:48:02.93,冬青黑体简体中文,,0,0,0,,且你存储了你想存储的\N{\fs14}and you've stored what you want,
Dialogue: 0,0:48:02.93,0:48:06.50,冬青黑体简体中文,,0,0,0,,你需要调用这个synchronize方法来同步\N{\fs14}you have to call this method synchronize on the instance.
Dialogue: 0,0:48:06.50,0:48:08.30,冬青黑体简体中文,,0,0,0,,[NSUserDefaults standardUserDefaults]\N{\fs14}So NSUserDefault, standard user default,
Dialogue: 0,0:48:08.30,0:48:09.14,冬青黑体简体中文,,0,0,0,,synchronize\N{\fs14}synchronize.
Dialogue: 0,0:48:09.14,0:48:11.45,冬青黑体简体中文,,0,0,0,,这是让它永久的东西\N{\fs14}That's what makes it permanent.
Dialogue: 0,0:48:11.45,0:48:15.49,冬青黑体简体中文,,0,0,0,,你写了一些东西 一些批处理 然后同步\N{\fs14}So you write a few things, a little batch, and then synchronize.
Dialogue: 0,0:48:15.49,0:48:18.85,冬青黑体简体中文,,0,0,0,,不要忘记同步\N{\fs14}Don't forget to synchronize.
Dialogue: 0,0:48:18.85,0:48:21.73,冬青黑体简体中文,,0,0,0,,如果你要在这里设置一些东西\N{\fs14}If you were to set some things in there
Dialogue: 0,0:48:21.73,0:48:25.66,冬青黑体简体中文,,0,0,0,,app在同步之前崩溃 它不会得到同步化\N{\fs14}and your app crashed before you did the synchronize, it would not get synced.
Dialogue: 0,0:48:25.66,0:48:29.56,冬青黑体简体中文,,0,0,0,,app重启时 你存入那里的东西会消失\N{\fs14}When your app launched again it would be gone, the stuff you put in there.
Dialogue: 0,0:48:31.80,0:48:37.43,冬青黑体简体中文,,0,0,0,,Foundation的核心部分中 我要讲的最后一点是\N{\fs14}The last thing really I'm going to talk about that's kind of in the core part of Foundation
Dialogue: 0,0:48:37.43,0:48:40.06,冬青黑体简体中文,,0,0,0,,NSRange 也是一种C struct\N{\fs14}is NSRange, which is just a C struct.
Dialogue: 0,0:48:40.06,0:48:42.31,冬青黑体简体中文,,0,0,0,,顾名思义 它描述一个范围\N{\fs14}It's exactly what you think: It describes a range.
Dialogue: 0,0:48:42.31,0:48:45.84,冬青黑体简体中文,,0,0,0,,这可以是字符串的范围 也可以是数组的范围\N{\fs14}This might be a range in a string or it could be a range in an array.
Dialogue: 0,0:48:45.84,0:48:47.58,冬青黑体简体中文,,0,0,0,,基本上是一个开始位置\N{\fs14}It's basically a starting location,
Dialogue: 0,0:48:47.58,0:48:49.47,冬青黑体简体中文,,0,0,0,,也就是NSUInteger location\N{\fs14}that's the NSUInteger location
Dialogue: 0,0:48:49.47,0:48:50.46,冬青黑体简体中文,,0,0,0,,还有长度\N{\fs14}and a length --
Dialogue: 0,0:48:50.46,0:48:53.84,冬青黑体简体中文,,0,0,0,,有多少字符 或数组中有多少项目\N{\fs14}how many characters or how many items in the array?
Dialogue: 0,0:48:53.84,0:48:58.40,冬青黑体简体中文,,0,0,0,,有一个重要的常数叫作NSNotFound\N{\fs14}There's an important constant called NSNotFound.
Dialogue: 0,0:48:58.40,0:49:03.41,冬青黑体简体中文,,0,0,0,,NSNotFound是range中location值\N{\fs14}NSNotFound is the value of location in a range
Dialogue: 0,0:49:03.41,0:49:06.42,冬青黑体简体中文,,0,0,0,,没有被发现 或者无效\N{\fs14}that was not found or that is otherwise invalid.
Dialogue: 0,0:49:06.42,0:49:10.15,冬青黑体简体中文,,0,0,0,,例如 在一个字符串中搜索子字符串\N{\fs14}Okay. So it's, like, search for a substring in a string
Dialogue: 0,0:49:10.15,0:49:13.20,冬青黑体简体中文,,0,0,0,,结果找不到 这就会返回一个range\N{\fs14}and it couldn't find it, you're going to get a range back
Dialogue: 0,0:49:13.20,0:49:17.22,冬青黑体简体中文,,0,0,0,,其位置将是NSNotFound\N{\fs14}that the location is going to be NSNotFound.
Dialogue: 0,0:49:17.22,0:49:19.37,冬青黑体简体中文,,0,0,0,,大家都理解吗\N{\fs14}Everyone understand that?
Dialogue: 0,0:49:19.37,0:49:22.70,冬青黑体简体中文,,0,0,0,,然后还有这个 NSRangePointer\N{\fs14}There's also this thing, NSRangePointer.
Dialogue: 0,0:49:22.70,0:49:25.03,冬青黑体简体中文,,0,0,0,,这其实是一个NSRange\N{\fs14}That's basically just an NSRange star.
Dialogue: 0,0:49:25.03,0:49:31.64,冬青黑体简体中文,,0,0,0,,我讲过 iOS中 我们不会将struct放到堆中\N{\fs14}Okay. Now I told you in iOS we don't really put structs in the heap and we don't.
Dialogue: 0,0:49:31.64,0:49:35.97,冬青黑体简体中文,,0,0,0,,这个NSRangePointer 用于引用调用range\N{\fs14}This NSRangePointer is for call by reference ranges.
Dialogue: 0,0:49:35.97,0:49:40.70,冬青黑体简体中文,,0,0,0,,有些方法会将NSRangePointer作为参数\N{\fs14}So some methods will take an NSRangePointer as an argument -- one of its arguments --
Dialogue: 0,0:49:40.70,0:49:41.91,冬青黑体简体中文,,0,0,0,,这里说的是\N{\fs14}and what it's saying there is,
Dialogue: 0,0:49:41.91,0:49:43.89,冬青黑体简体中文,,0,0,0,,如果你将一个指向range的指针传递给我\N{\fs14}"If you pass me a pointer to a range,
Dialogue: 0,0:49:43.89,0:49:46.10,冬青黑体简体中文,,0,0,0,,我将使用一些信息填充它\N{\fs14}I'll fill it in with some information."
Dialogue: 0,0:49:46.10,0:49:47.93,冬青黑体简体中文,,0,0,0,,这里你几乎总是可以传递null\N{\fs14}Almost always you can pass null there
Dialogue: 0,0:49:47.93,0:49:50.57,冬青黑体简体中文,,0,0,0,,它不会填入任何信息 因为你没有指向一个range\N{\fs14}and it won't fill the information in because you won't be pointing to a range.
Dialogue: 0,0:49:50.57,0:49:55.42,冬青黑体简体中文,,0,0,0,,但这是用于引用 大家都理解引用调用吗\N{\fs14}But it's for reference. Everyone know what it means to call by reference?
Dialogue: 0,0:49:55.42,0:49:56.65,冬青黑体简体中文,,0,0,0,,有问题\N{\fs14}Question?
Dialogue: 0,0:49:58.59,0:50:01.73,冬青黑体简体中文,,0,0,0,,学生：我只是好奇 为什么你用unsigned\N{\fs14}> Just out of curiosity, why are you using unsigned
Dialogue: 0,0:50:01.73,0:50:05.51,冬青黑体简体中文,,0,0,0,,或者说为什么苹果选择对range使用unsigned\N{\fs14}or why did Apple choose to use unsigned on its range.
Dialogue: 0,0:50:05.51,0:50:09.89,冬青黑体简体中文,,0,0,0,,看起来好像不能用负数来表示range\N{\fs14}It seems like you can't represent a range over negative numbers.
Dialogue: 0,0:50:09.89,0:50:12.57,冬青黑体简体中文,,0,0,0,,老师：问题是 为什么苹果选择\N{\fs14}> Yeah. So the question is: Why did Apple choose
Dialogue: 0,0:50:12.57,0:50:15.03,冬青黑体简体中文,,0,0,0,,将location值预设为无符号整数\N{\fs14}to make location be an unsigned integer?
Dialogue: 0,0:50:15.03,0:50:18.88,冬青黑体简体中文,,0,0,0,,换句话说 为什么range只能是正的范围\N{\fs14}In other words, why can the range only be a positive range?
Dialogue: 0,0:50:18.88,0:50:22.47,冬青黑体简体中文,,0,0,0,,我想 主要原因可能在于\N{\fs14}And I think the main reason they did that is, you know,
Dialogue: 0,0:50:22.47,0:50:24.82,冬青黑体简体中文,,0,0,0,,他们是为自己的目的设计NSRange的\N{\fs14}they designed NSRange for their own purposes,
Dialogue: 0,0:50:24.82,0:50:27.22,冬青黑体简体中文,,0,0,0,,例如数组的范围 字符串的范围\N{\fs14}like ranges in arrays, ranges in strings.
Dialogue: 0,0:50:27.22,0:50:28.96,冬青黑体简体中文,,0,0,0,,他们不想像那样表示\N{\fs14}They never want to represent that.
Dialogue: 0,0:50:28.96,0:50:34.24,冬青黑体简体中文,,0,0,0,,而且我敢打赌 NSNotFound要么是最大整数\N{\fs14}And I will bet you dollars to doughnuts NSNotFound is either the maximum integer
Dialogue: 0,0:50:34.24,0:50:36.67,冬青黑体简体中文,,0,0,0,,要么是负数\N{\fs14}or it's minus, you know, whatever, negative,
Dialogue: 0,0:50:36.67,0:50:38.07,冬青黑体简体中文,,0,0,0,,这些有时是一样的\N{\fs14}which sometimes are the same thing, right?
Dialogue: 0,0:50:38.07,0:50:39.76,冬青黑体简体中文,,0,0,0,,计算机科学就是这样\N{\fs14}If you know how computer science works,
Dialogue: 0,0:50:39.76,0:50:42.88,冬青黑体简体中文,,0,0,0,,很多时候 所有二进制数倒过来 这就是-1\N{\fs14}a lot of times it's all the bits inverted, that's minus one
Dialogue: 0,0:50:42.88,0:50:44.35,冬青黑体简体中文,,0,0,0,,这也是范围的最后\N{\fs14}that also would be at the end of the range.
Dialogue: 0,0:50:44.35,0:50:48.76,冬青黑体简体中文,,0,0,0,,我想 这是因为他们不需要其它的\N{\fs14}So I think it's just because they didn't need it for anything else and they wanted
Dialogue: 0,0:50:48.76,0:50:51.76,冬青黑体简体中文,,0,0,0,,他们希望自己的API尽可能简洁明了\N{\fs14}to make their API clearer possibly.
Dialogue: 0,0:50:51.76,0:50:52.54,冬青黑体简体中文,,0,0,0,,我不知道\N{\fs14}I don't know.
Dialogue: 0,0:50:52.54,0:50:58.08,冬青黑体简体中文,,0,0,0,,我从未在苹果干过 所以我不知道他们为什么那么做\N{\fs14}I don't work at Apple -- never did -- so I don't really know why they did that.
Dialogue: 0,0:50:58.08,0:51:01.59,冬青黑体简体中文,,0,0,0,,以上就是Foundation方面 我要讲的所有内容了\N{\fs14}Okay. So that's really kind of it for the Foundational stuff.
Dialogue: 0,0:51:01.59,0:51:03.73,冬青黑体简体中文,,0,0,0,,我还会讲到Foundation中的一些类\N{\fs14}I am going to talk about some more classes in Foundation.
Dialogue: 0,0:51:03.73,0:51:07.90,冬青黑体简体中文,,0,0,0,,但首先 我先转换一下主题 讨论UIKit中的一些类\N{\fs14}But first we're going to take a little detour and talk about a couple classes in UIkit.
Dialogue: 0,0:51:07.90,0:51:10.89,冬青黑体简体中文,,0,0,0,,也就是颜色和字体\N{\fs14}And those are colors and fonts.
Dialogue: 0,0:51:10.89,0:51:15.49,冬青黑体简体中文,,0,0,0,,UIColor是超级简单的类 表示颜色\N{\fs14}All right. So UIColor, super simple class, represents a color.
Dialogue: 0,0:51:15.49,0:51:18.87,冬青黑体简体中文,,0,0,0,,颜色可以用很多方式表示\N{\fs14}The color can be represented in so many different ways,
Dialogue: 0,0:51:18.87,0:51:21.25,冬青黑体简体中文,,0,0,0,,包括RGB 即红绿蓝\N{\fs14}RGB -- red, green, blue, right?
Dialogue: 0,0:51:21.25,0:51:23.23,冬青黑体简体中文,,0,0,0,,HSB 即色调 饱和度 亮度\N{\fs14}HSB, that's hue, saturation, and brightness.
Dialogue: 0,0:51:23.23,0:51:24.91,冬青黑体简体中文,,0,0,0,,它甚至可以是一个样式\N{\fs14}It could even be a pattern.
Dialogue: 0,0:51:24.91,0:51:28.67,冬青黑体简体中文,,0,0,0,,你可以让颜色是一个UIImage样式\N{\fs14}Okay. So you can have a color that is a UI image pattern in there.
Dialogue: 0,0:51:28.67,0:51:31.36,冬青黑体简体中文,,0,0,0,,当你用那个颜色绘图时 它会用那个样式\N{\fs14}And when you draw with that color, it will draw with the pattern.
Dialogue: 0,0:51:31.36,0:51:35.57,冬青黑体简体中文,,0,0,0,,颜色 超级强大 但API很简单明了\N{\fs14}So color, super powerful but nice and simple API.
Dialogue: 0,0:51:35.57,0:51:38.44,冬青黑体简体中文,,0,0,0,,颜色还可以有alpha\N{\fs14}Colors can also have alpha.
Dialogue: 0,0:51:38.44,0:51:41.30,冬青黑体简体中文,,0,0,0,,多少人不知道alpha是什么\N{\fs14}Okay. How many people in here do not know what alpha is?
Dialogue: 0,0:51:41.30,0:51:42.81,冬青黑体简体中文,,0,0,0,,没听过alpha这个词\N{\fs14}Never heard the phrase "alpha"?
Dialogue: 0,0:51:42.81,0:51:44.08,冬青黑体简体中文,,0,0,0,,大家都知道alpha是什么\N{\fs14}So everybody knows what alpha is.
Dialogue: 0,0:51:44.08,0:51:45.30,冬青黑体简体中文,,0,0,0,,它是第一个希腊字母\N{\fs14}Okay. So that's a first.
Dialogue: 0,0:51:45.30,0:51:49.03,冬青黑体简体中文,,0,0,0,,alpha在计算机图形中表示透明度\N{\fs14}So alpha, which in computer graphics is how transparent it
Dialogue: 0,0:51:49.03,0:51:53.12,冬青黑体简体中文,,0,0,0,,1表示完全不透明 0表示完全透明\N{\fs14}is -- one being fully opaque and zero being fully transparent.
Dialogue: 0,0:51:53.12,0:51:56.75,冬青黑体简体中文,,0,0,0,,你可以创建部分透明的颜色\N{\fs14}You can create colors that are partially transparent.
Dialogue: 0,0:51:56.75,0:52:00.58,冬青黑体简体中文,,0,0,0,,用它们绘图时 你会看到它们是如何填充的\N{\fs14}And then if you draw with them, you'll be able to see behind where you filled in.
Dialogue: 0,0:52:00.58,0:52:02.73,冬青黑体简体中文,,0,0,0,,颜色很酷\N{\fs14}So colors are really cool.
Dialogue: 0,0:52:02.73,0:52:06.14,冬青黑体简体中文,,0,0,0,,颜色有一些标准的\N{\fs14}There's a handful of kind of standard colors --
Dialogue: 0,0:52:06.14,0:52:09.04,冬青黑体简体中文,,0,0,0,,绿色 红色 紫色 等等\N{\fs14}the green color, red color, purple color, whatever.
Dialogue: 0,0:52:09.04,0:52:12.28,冬青黑体简体中文,,0,0,0,,你可以在说明文档中找到这些\N{\fs14}You can look in its documentation to find those.
Dialogue: 0,0:52:12.28,0:52:13.66,冬青黑体简体中文,,0,0,0,,它们只不过是类方法\N{\fs14}They're just class method.
Dialogue: 0,0:52:13.66,0:52:16.43,冬青黑体简体中文,,0,0,0,,然后还有一些方法 像lightTextColor\N{\fs14}There's also a few methods in there like the light text color,
Dialogue: 0,0:52:16.43,0:52:19.88,冬青黑体简体中文,,0,0,0,,这是为浅色文本 禁用文本这些准备的灰色阴影\N{\fs14}which is the shade of gray for light text, disabled text, or whatever.
Dialogue: 0,0:52:19.88,0:52:21.62,冬青黑体简体中文,,0,0,0,,这些你们都可以看看\N{\fs14}So you can look at all that.
Dialogue: 0,0:52:21.62,0:52:22.80,冬青黑体简体中文,,0,0,0,,颜色很简单\N{\fs14}So colors are simple.
Dialogue: 0,0:52:22.80,0:52:25.32,冬青黑体简体中文,,0,0,0,,字体 没这么简单\N{\fs14}Fonts, not so simple.
Dialogue: 0,0:52:25.32,0:52:32.00,冬青黑体简体中文,,0,0,0,,iOS7中 将字体设置正确是非常重要的\N{\fs14}Now, fonts in iOS 7 are incredibly important to get right.
Dialogue: 0,0:52:32.00,0:52:38.37,冬青黑体简体中文,,0,0,0,,iOS7的UI设计 很大一部分都取决于字体选择\N{\fs14}A huge percentage of good iOS 7 UI design is picking the right fronts,
Dialogue: 0,0:52:38.37,0:52:44.32,冬青黑体简体中文,,0,0,0,,使用方式正确 以及屏幕排列美观\N{\fs14}and using fonts in the right way, arranging fonts on screen in a nice way.
Dialogue: 0,0:52:44.32,0:52:45.13,冬青黑体简体中文,,0,0,0,,超级重要\N{\fs14}Super important.
Dialogue: 0,0:52:45.13,0:52:48.17,冬青黑体简体中文,,0,0,0,,所以iOS7中有很多新支持\N{\fs14}So there's a lot of support in iOS 7 that's new
Dialogue: 0,0:52:48.17,0:52:52.72,冬青黑体简体中文,,0,0,0,,帮助我们更容易将字体设置正确\N{\fs14}that is basically about making it easy to do the right thing with fonts.
Dialogue: 0,0:52:52.72,0:52:55.70,冬青黑体简体中文,,0,0,0,,这里我列出了一些iOS7 app的例子\N{\fs14}So I put up some examples of some iOS 7 apps here.
Dialogue: 0,0:52:55.70,0:52:59.69,冬青黑体简体中文,,0,0,0,,可以看到所有这些例子中 字体具有怎样的重要作用\N{\fs14}And you can see how front and center fonts are on all these things.
Dialogue: 0,0:52:59.69,0:53:04.25,冬青黑体简体中文,,0,0,0,,如果字体很丑 例如没有用粗体\N{\fs14}If you had ugly fonts here or you didn't have bold,
Dialogue: 0,0:53:04.25,0:53:07.07,冬青黑体简体中文,,0,0,0,,或者字体之间揉在一起\N{\fs14}or you had, you know, fronts that were too smashed together
Dialogue: 0,0:53:07.07,0:53:10.13,冬青黑体简体中文,,0,0,0,,或很难读 或颜色错误\N{\fs14}or hard to read or the wrong color,
Dialogue: 0,0:53:10.13,0:53:16.01,冬青黑体简体中文,,0,0,0,,这些UI将会很难辨识\N{\fs14}these UIs would be, you know, impossible to decipher or very difficult to decipher here.
Dialogue: 0,0:53:16.01,0:53:22.02,冬青黑体简体中文,,0,0,0,,所以 颜色 背景颜色 还有字体大小\N{\fs14}So color, and background colors, and, you know, the size of fonts,
Dialogue: 0,0:53:22.02,0:53:26.57,冬青黑体简体中文,,0,0,0,,所有这些在应用中都至关重要\N{\fs14}and all these things are all critically important in all of these applications.
Dialogue: 0,0:53:26.57,0:53:30.54,冬青黑体简体中文,,0,0,0,,我将简单讲一下如何处理这些\N{\fs14}So we're going to talk a little bit about how to deal
Dialogue: 0,0:53:30.54,0:53:34.84,冬青黑体简体中文,,0,0,0,,以及iOS7中所有这些是如何做到的\N{\fs14}with this and what's in there for iOS 7 to make this happen.
Dialogue: 0,0:53:34.84,0:53:39.97,冬青黑体简体中文,,0,0,0,,很不幸 我课上没有足够时间详细讲解所有这些\N{\fs14}Unfortunately, I don't have enough time in lecture in general to go through all of this.
Dialogue: 0,0:53:39.97,0:53:44.15,冬青黑体简体中文,,0,0,0,,我们会在关于UI的课堂和演示中\N{\fs14}I'll kind of distribute little bits of wisdom about it as we go
Dialogue: 0,0:53:44.15,0:53:49.13,冬青黑体简体中文,,0,0,0,,零星讲到其中一些内容\N{\fs14}through various UIs in lecture, and demos, and things like that.
Dialogue: 0,0:53:49.13,0:53:51.65,冬青黑体简体中文,,0,0,0,,今天我将大致介绍一下基础\N{\fs14}What I'm going to try and give you today is just the basis
Dialogue: 0,0:53:51.65,0:53:55.05,冬青黑体简体中文,,0,0,0,,告诉你们如何将文字呈现在屏幕上\N{\fs14}for how we present text on screen.
Dialogue: 0,0:53:55.05,0:53:57.02,冬青黑体简体中文,,0,0,0,,这方面有哪些基本内容\N{\fs14}What the primitives are for that
Dialogue: 0,0:53:57.02,0:53:59.98,冬青黑体简体中文,,0,0,0,,如何正确使用并保持一致\N{\fs14}and how we do it in the right way so that we get consistency.
Dialogue: 0,0:53:59.98,0:54:01.62,冬青黑体简体中文,,0,0,0,,注意 所有这些app中\N{\fs14}See, the one thing about all these apps --
Dialogue: 0,0:54:01.62,0:54:06.25,冬青黑体简体中文,,0,0,0,,都有粗体 以及可以点击的字体\N{\fs14}do you see how the bold font, and the fonts you can click on,
Dialogue: 0,0:54:06.25,0:54:08.17,冬青黑体简体中文,,0,0,0,,还有小的子标题字体\N{\fs14}and the kind of little subheading fonts,
Dialogue: 0,0:54:08.17,0:54:13.30,冬青黑体简体中文,,0,0,0,,它们都是相关的字体 相同种类 也许 也许不是\N{\fs14}they're all related fonts, same family -- maybe, maybe not.
Dialogue: 0,0:54:13.30,0:54:14.67,冬青黑体简体中文,,0,0,0,,但它们是相关的\N{\fs14}But they're related.
Dialogue: 0,0:54:14.67,0:54:16.30,冬青黑体简体中文,,0,0,0,,大小相同\N{\fs14}They're the same sizes.
Dialogue: 0,0:54:16.30,0:54:19.44,冬青黑体简体中文,,0,0,0,,看起来一样 因此所有app都有类似的外观\N{\fs14}They look the same. So all the apps kind of have a similar look.
Dialogue: 0,0:54:19.44,0:54:21.90,冬青黑体简体中文,,0,0,0,,因为它们的字体使用都很合适\N{\fs14}That's because they're all using fonts properly.
Dialogue: 0,0:54:21.90,0:54:24.96,冬青黑体简体中文,,0,0,0,,我来讲讲字体\N{\fs14}So let's talk about fonts.
Dialogue: 0,0:54:24.96,0:54:27.44,冬青黑体简体中文,,0,0,0,,关于字体要了解的最重要一点是\N{\fs14}The most important thing to understand about fonts is
Dialogue: 0,0:54:27.44,0:54:31.58,冬青黑体简体中文,,0,0,0,,如果你在展示用户内容 也就是用户的信息\N{\fs14}that if you're displaying user content -- okay, that the user's information.
Dialogue: 0,0:54:31.58,0:54:34.73,冬青黑体简体中文,,0,0,0,,在日历中 也就是预约 日期\N{\fs14}So in the calendar that's the appointments, and the days
Dialogue: 0,0:54:34.73,0:54:37.05,冬青黑体简体中文,,0,0,0,,星期几 月份 所有这些\N{\fs14}of the week, and the month, and all those things.
Dialogue: 0,0:54:37.05,0:54:41.81,冬青黑体简体中文,,0,0,0,,在天气中 则是温度 城市名等等\N{\fs14}In the weather it's the temperature, and the name of the city, and things like that.
Dialogue: 0,0:54:41.81,0:54:46.73,冬青黑体简体中文,,0,0,0,,在计时应用中 则是时钟所在城市\N{\fs14}In the timer app it's the city that the clock is in.
Dialogue: 0,0:54:46.73,0:54:48.32,冬青黑体简体中文,,0,0,0,,如果是用户内容\N{\fs14}So if it's user content --
Dialogue: 0,0:54:48.32,0:54:51.84,冬青黑体简体中文,,0,0,0,,也就是说 不是按钮上的文字\N{\fs14}in other words, it's not the text on a button.
Dialogue: 0,0:54:51.84,0:54:55.48,冬青黑体简体中文,,0,0,0,,按钮上的文字便于用户点击 如编辑等等\N{\fs14}It's not a text on a button that user's clicking like edit or something like that.
Dialogue: 0,0:54:55.48,0:54:58.54,冬青黑体简体中文,,0,0,0,,那么你就需要使用首选字体 所谓的首选字体\N{\fs14}Then you want to use a preferred font, what's called a "preferred font."
Dialogue: 0,0:54:58.54,0:55:01.01,冬青黑体简体中文,,0,0,0,,所以你需要这种很重要的方法\N{\fs14}And so you want this incredibly important method.
Dialogue: 0,0:55:01.01,0:55:03.64,冬青黑体简体中文,,0,0,0,,UIFont中如果你只学一种方法\N{\fs14}If you only learn one method in all of UI font,
Dialogue: 0,0:55:03.64,0:55:05.22,冬青黑体简体中文,,0,0,0,,那肯定就是这种iOS7方法\N{\fs14}it's this iOS 7 method
Dialogue: 0,0:55:05.22,0:55:07.46,冬青黑体简体中文,,0,0,0,,叫作preferredFontForTextStyle\N{\fs14}called "preferred font for text style."
Dialogue: 0,0:55:07.46,0:55:10.02,冬青黑体简体中文,,0,0,0,,文本样式参数是一个字符串\N{\fs14}The text style argument is a string.
Dialogue: 0,0:55:10.02,0:55:11.66,冬青黑体简体中文,,0,0,0,,你将使用一个常数\N{\fs14}You use a constant
Dialogue: 0,0:55:11.66,0:55:14.65,冬青黑体简体中文,,0,0,0,,这可以在UIFontDescriptor中查到\N{\fs14}that you're going to look up in UI font descriptor, actually.
Dialogue: 0,0:55:14.65,0:55:18.29,冬青黑体简体中文,,0,0,0,,查看UIFont 四处点一下 你可以找到它\N{\fs14}If you go through UI font, you can link click through and find it.
Dialogue: 0,0:55:18.29,0:55:20.15,冬青黑体简体中文,,0,0,0,,这里有体样式\N{\fs14}And so there's the body style.
Dialogue: 0,0:55:20.15,0:55:24.56,冬青黑体简体中文,,0,0,0,,这是体中的文字 体也就是显示的主要部分\N{\fs14}So that's text that's in the body, the main part of what's being displayed.
Dialogue: 0,0:55:24.56,0:55:26.75,冬青黑体简体中文,,0,0,0,,例如在预约中 这将是…\N{\fs14}So like, in an appointment that would be --
Dialogue: 0,0:55:26.75,0:55:28.16,冬青黑体简体中文,,0,0,0,,在日历中\N{\fs14}like in a calendar item
Dialogue: 0,0:55:28.16,0:55:32.08,冬青黑体简体中文,,0,0,0,,这将是关于某预约时实际将会发生什么的信息\N{\fs14}that would be the actual information about what's going to happen at that appointment.
Dialogue: 0,0:55:32.08,0:55:34.10,冬青黑体简体中文,,0,0,0,,然后还有标题样式\N{\fs14}And then there's a headline style.
Dialogue: 0,0:55:34.10,0:55:36.15,冬青黑体简体中文,,0,0,0,,这显然用于标题\N{\fs14}So that would be, obviously, a header.
Dialogue: 0,0:55:36.15,0:55:40.37,冬青黑体简体中文,,0,0,0,,还有脚注 解说文字 例如图像上的解说文字 等等\N{\fs14}There's footnotes, captions, like a caption on an image, things like that.
Dialogue: 0,0:55:40.37,0:55:43.44,冬青黑体简体中文,,0,0,0,,这些样式总共有大概八个\N{\fs14}There's about, I think, eight or so of these.
Dialogue: 0,0:55:43.44,0:55:45.49,冬青黑体简体中文,,0,0,0,,你们应该熟悉\N{\fs14}And you should familiarize yourself
Dialogue: 0,0:55:45.49,0:55:49.07,冬青黑体简体中文,,0,0,0,,什么语义环境下应该使用什么样式\N{\fs14}with what circumstances semantically those things should be used in.
Dialogue: 0,0:55:49.07,0:55:53.06,冬青黑体简体中文,,0,0,0,,你们在app中使用字体时 应该从这些里面选择\N{\fs14}And then when you want a font in your app, you should be using one of these.
Dialogue: 0,0:55:53.06,0:55:55.43,冬青黑体简体中文,,0,0,0,,用于用户内容\N{\fs14}For user content.
Dialogue: 0,0:55:55.43,0:55:57.00,冬青黑体简体中文,,0,0,0,,还有系统字体\N{\fs14}There's also system fonts.
Dialogue: 0,0:55:57.00,0:55:58.68,冬青黑体简体中文,,0,0,0,,这些是按钮上的字体\N{\fs14}These are what goes on buttons.
Dialogue: 0,0:55:58.68,0:56:02.60,冬青黑体简体中文,,0,0,0,,不要在用户内容中使用系统字体\N{\fs14}Don't use the system fonts for user content.
Dialogue: 0,0:56:02.60,0:56:06.56,冬青黑体简体中文,,0,0,0,,有时 在按钮上使用首选字体是可以的\N{\fs14}Sometimes it's okay to use a preferred font on a button.
Dialogue: 0,0:56:06.56,0:56:08.71,冬青黑体简体中文,,0,0,0,,这取决于按钮的标题是否会变化\N{\fs14}It depends on whether the title of the button might change,
Dialogue: 0,0:56:08.71,0:56:11.45,冬青黑体简体中文,,0,0,0,,取决于用户内容\N{\fs14}depending on user's, you know, content.
Dialogue: 0,0:56:11.45,0:56:13.96,冬青黑体简体中文,,0,0,0,,这是按钮上的用户内容\N{\fs14}Basically it's the user's content on a button.
Dialogue: 0,0:56:13.96,0:56:15.09,冬青黑体简体中文,,0,0,0,,这没问题\N{\fs14}That would be okay.
Dialogue: 0,0:56:15.09,0:56:18.57,冬青黑体简体中文,,0,0,0,,但一般不要对用户内容使用系统字体\N{\fs14}But you generally wouldn't want to use system fonts for user's content.
Dialogue: 0,0:56:18.57,0:56:23.88,冬青黑体简体中文,,0,0,0,,这是按钮上用的字体 你们知道 就是这样\N{\fs14}So this is what's on a button, what's -- you know, that kind of thing.
Dialogue: 0,0:56:26.28,0:56:28.14,冬青黑体简体中文,,0,0,0,,UIFontDescriptor\N{\fs14}UI font descriptor.
Dialogue: 0,0:56:28.14,0:56:31.46,冬青黑体简体中文,,0,0,0,,我在发布的幻灯片中额外加了一些\N{\fs14}I put some extra slides in what I posted
Dialogue: 0,0:56:31.46,0:56:34.03,冬青黑体简体中文,,0,0,0,,关于UIFontDescriptor的内容\N{\fs14}that talks more about UI font descriptor.
Dialogue: 0,0:56:34.03,0:56:35.98,冬青黑体简体中文,,0,0,0,,这里我不打算细讲\N{\fs14}I'm not going to go through them here.
Dialogue: 0,0:56:35.98,0:56:37.65,冬青黑体简体中文,,0,0,0,,你们可以自己看一下\N{\fs14}You can look through them, just kind of get a little bit
Dialogue: 0,0:56:37.65,0:56:39.68,冬青黑体简体中文,,0,0,0,,从而对UIFontDescriptor有一定了解\N{\fs14}of a hint for UI font descriptor.
Dialogue: 0,0:56:39.68,0:56:41.40,冬青黑体简体中文,,0,0,0,,关于这个我就想说一点\N{\fs14}But the bottom line is:
Dialogue: 0,0:56:41.40,0:56:46.66,冬青黑体简体中文,,0,0,0,,字体不是计算机程序员设计的 而是艺术家设计的\N{\fs14}Fonts are designed not by computer programmers but by artists.
Dialogue: 0,0:56:46.66,0:56:50.98,冬青黑体简体中文,,0,0,0,,艺术家设计字体 也许设计已经有数百年历史了\N{\fs14}Artists design fonts, and they've been designing them for hundreds of years.
Dialogue: 0,0:56:50.98,0:56:56.30,冬青黑体简体中文,,0,0,0,,也许有几百年历史了 这是印刷出版刚兴起的时候\N{\fs14}Yeah, probably couple hundred years since the ledgers, since presses were made.
Dialogue: 0,0:56:56.30,0:56:58.87,冬青黑体简体中文,,0,0,0,,古腾堡是什么时候我不大确定\N{\fs14}I don't know when Gutenberg was exactly.
Dialogue: 0,0:56:58.87,0:57:00.51,冬青黑体简体中文,,0,0,0,,这考了考我的历史\N{\fs14}Testing my history here.
Dialogue: 0,0:57:00.51,0:57:02.19,冬青黑体简体中文,,0,0,0,,但这些设计\N{\fs14}But those were designed.
Dialogue: 0,0:57:02.19,0:57:06.94,冬青黑体简体中文,,0,0,0,,是很久以前雕刻在铅块上使用的\N{\fs14}You know, back then you actually etched on pieces of lead or whatever.
Dialogue: 0,0:57:06.94,0:57:12.13,冬青黑体简体中文,,0,0,0,,而现在 设计是在PhotoShop或Illustrator\N{\fs14}Now they're designed in, you know, PhotoShop or Illustrator probably type, you know,
Dialogue: 0,0:57:12.13,0:57:14.63,冬青黑体简体中文,,0,0,0,,或别的什么矢量图形设计工具上\N{\fs14}vector graphics designing tools.
Dialogue: 0,0:57:14.63,0:57:17.01,冬青黑体简体中文,,0,0,0,,这个的问题是\N{\fs14}And the problem with that is
Dialogue: 0,0:57:17.01,0:57:20.24,冬青黑体简体中文,,0,0,0,,它们并不一定满足我们计算机科学家所想要的\N{\fs14}that they don't fit what we computer scientists want,
Dialogue: 0,0:57:20.24,0:57:22.84,冬青黑体简体中文,,0,0,0,,也就是 我们想要这种字体的粗体版本\N{\fs14}which is we want the bold version of this font,
Dialogue: 0,0:57:22.84,0:57:26.24,冬青黑体简体中文,,0,0,0,,我们想要斜体 我们想要细体\N{\fs14}we want the italic version, we want the narrow version.
Dialogue: 0,0:57:26.24,0:57:30.92,冬青黑体简体中文,,0,0,0,,除非字体设计者实际设计了粗体或斜体\N{\fs14}Okay. Unless the font designer actually designs a bold font or an italic font
Dialogue: 0,0:57:30.92,0:57:34.15,冬青黑体简体中文,,0,0,0,,一般而言我们没有这些\N{\fs14}[inaudible], we don't get it. We don't get one of those.
Dialogue: 0,0:57:34.15,0:57:37.29,冬青黑体简体中文,,0,0,0,,我们可以尝试将它拉粗一些\N{\fs14}We could try and somehow scrunch it up to look more bold,
Dialogue: 0,0:57:37.29,0:57:40.03,冬青黑体简体中文,,0,0,0,,但这通常看起来很糟糕\N{\fs14}but that usually looks, like, bad.
Dialogue: 0,0:57:40.03,0:57:42.43,冬青黑体简体中文,,0,0,0,,看起来不会好\N{\fs14}That does not look good.
Dialogue: 0,0:57:42.43,0:57:44.79,冬青黑体简体中文,,0,0,0,,UIFontDescriptor是iOS7中的新特性\N{\fs14}So UI font descriptor's new in iOS 7.
Dialogue: 0,0:57:44.79,0:57:51.94,冬青黑体简体中文,,0,0,0,,它会尝试将类别施加在未分类化的字体上\N{\fs14}It attempts to put categories on fonts that defy categorization.
Dialogue: 0,0:57:53.36,0:57:57.32,冬青黑体简体中文,,0,0,0,,UIFontDescriptor在这方面有很多知识\N{\fs14}So the UI font descriptor has a lot of knowledge in it
Dialogue: 0,0:57:57.32,0:58:00.83,冬青黑体简体中文,,0,0,0,,关于某字体是否有黑体版本\N{\fs14}about faces and is there a bold version of this,
Dialogue: 0,0:58:00.83,0:58:03.74,冬青黑体简体中文,,0,0,0,,有没有细体 有没有斜体\N{\fs14}is there a condensed version, is there an italic version?
Dialogue: 0,0:58:03.74,0:58:07.46,冬青黑体简体中文,,0,0,0,,它会将此映射到我们计算机科学家希望处理的事物上\N{\fs14}And so it maps that into something we, as computer scientists, want to do
Dialogue: 0,0:58:07.46,0:58:10.66,冬青黑体简体中文,,0,0,0,,因为我们希望将黑体的事物显示在屏幕上\N{\fs14}because we want to put something in bold on the screen.
Dialogue: 0,0:58:10.66,0:58:13.28,冬青黑体简体中文,,0,0,0,,UIFontDescriptor就是这样了\N{\fs14}So that's what UI font descriptor is all about.
Dialogue: 0,0:58:13.28,0:58:17.35,冬青黑体简体中文,,0,0,0,,哪怕大小 也通常设计到字体中\N{\fs14}Even size, by the way, is designed into a font often.
Dialogue: 0,0:58:17.35,0:58:23.37,冬青黑体简体中文,,0,0,0,,字体设计者对较大S的设计中 会有更多曲线\N{\fs14}A designer of a font will design a larger S with a little more curve here and there
Dialogue: 0,0:58:23.37,0:58:26.04,冬青黑体简体中文,,0,0,0,,而较小S则不是这样\N{\fs14}than a smaller S. Okay?
Dialogue: 0,0:58:26.04,0:58:29.20,冬青黑体简体中文,,0,0,0,,大小并不只是矢量图形的放大和缩小\N{\fs14}Size is not just a matter of vector graphic zooming in and out --
Dialogue: 0,0:58:29.20,0:58:31.16,冬青黑体简体中文,,0,0,0,,有时 它会取决于字体\N{\fs14}sometimes, it depends on the font.
Dialogue: 0,0:58:31.16,0:58:35.69,冬青黑体简体中文,,0,0,0,,你们可以看看幻灯片 看具体情况是怎样的\N{\fs14}So anyway, look at that, at slides that are in there to try and figure that out.
Dialogue: 0,0:58:35.69,0:58:39.38,冬青黑体简体中文,,0,0,0,,作业中没有任何内容涉及到UIFontDescriptor\N{\fs14}There's nothing you will have to do in your homeworks that is font descriptor.
Dialogue: 0,0:58:39.38,0:58:43.29,冬青黑体简体中文,,0,0,0,,你们可能需要考虑字体 但UIFontDescriptor不需要\N{\fs14}You might have to do fonts but not font descriptors, I don't think.
Dialogue: 0,0:58:43.29,0:58:48.30,冬青黑体简体中文,,0,0,0,,有兴趣的话 你们可以做一些更进阶的东西\N{\fs14}You might want to if you want to do some advanced stuff.
Dialogue: 0,0:58:48.30,0:58:49.96,冬青黑体简体中文,,0,0,0,,理解了这些\N{\fs14}So understand, though, that,
Dialogue: 0,0:58:49.96,0:58:51.84,冬青黑体简体中文,,0,0,0,,当你使用UIFontDescriptor\N{\fs14}yeah, when you do a font descriptor and you
Dialogue: 0,0:58:51.85,0:58:54.41,冬青黑体简体中文,,0,0,0,,要它给你字体相应的粗体\N{\fs14}ask it for a bold version of a font,
Dialogue: 0,0:58:54.41,0:58:56.07,冬青黑体简体中文,,0,0,0,,你可能得不到粗体\N{\fs14}you might not get a bold version.
Dialogue: 0,0:58:56.07,0:58:58.27,冬青黑体简体中文,,0,0,0,,你会得到它能给出的最接近的东西\N{\fs14}You'll get the best thing it can come up with,
Dialogue: 0,0:58:58.27,0:58:59.63,冬青黑体简体中文,,0,0,0,,但也许看起来并非粗体\N{\fs14}but it might not actually look bold,
Dialogue: 0,0:58:59.63,0:59:03.12,冬青黑体简体中文,,0,0,0,,取决于是什么字体 它有没有相应的粗体 等等\N{\fs14}depending on what font it is and whether it has a bold, etc.
Dialogue: 0,0:59:04.42,0:59:07.47,冬青黑体简体中文,,0,0,0,,下面我们来谈 文本在屏幕上的效果\N{\fs14}So now let's talk about how text looks on screen.
Dialogue: 0,0:59:07.47,0:59:10.60,冬青黑体简体中文,,0,0,0,,字体是文本屏幕效果的一个重要部分\N{\fs14}Well, the font is a big part of how text looks on screen.
Dialogue: 0,0:59:10.60,0:59:12.23,冬青黑体简体中文,,0,0,0,,取决于你选择什么字体\N{\fs14}Depending on which font you pick, that's going
Dialogue: 0,0:59:12.23,0:59:13.71,冬青黑体简体中文,,0,0,0,,这会很大程度上决定效果\N{\fs14}to determine a lot of what it looks like.
Dialogue: 0,0:59:13.71,0:59:15.11,冬青黑体简体中文,,0,0,0,,但还有很多其它因素\N{\fs14}But there's a lot of other things
Dialogue: 0,0:59:15.11,0:59:17.08,冬青黑体简体中文,,0,0,0,,会决定字体在屏幕上的效果\N{\fs14}that determine what a font looks like on screen.
Dialogue: 0,0:59:17.08,0:59:20.43,冬青黑体简体中文,,0,0,0,,例如 文本有没有下划线\N{\fs14}For example, is the thing underlined?
Dialogue: 0,0:59:20.43,0:59:21.74,冬青黑体简体中文,,0,0,0,,是不是空心字体\N{\fs14}Is it outlined?
Dialogue: 0,0:59:21.74,0:59:27.36,冬青黑体简体中文,,0,0,0,,字体的外边缘有多强的描边\N{\fs14}How strongly stroked is the outer edge of the font?
Dialogue: 0,0:59:27.36,0:59:29.96,冬青黑体简体中文,,0,0,0,,这些都独立于字体\N{\fs14}Those things are all kind of independent of the font.
Dialogue: 0,0:59:29.96,0:59:32.51,冬青黑体简体中文,,0,0,0,,这些可以应用到任何字体\N{\fs14}You can apply these things to any font.
Dialogue: 0,0:59:32.51,0:59:35.68,冬青黑体简体中文,,0,0,0,,所以 Foundation中有一个新类你们会学到\N{\fs14}So there's a new class that you're going to learn that's in Foundation
Dialogue: 0,0:59:35.68,0:59:37.82,冬青黑体简体中文,,0,0,0,,叫NSAttributedString\N{\fs14}called NSAttributedString.
Dialogue: 0,0:59:37.82,0:59:40.32,冬青黑体简体中文,,0,0,0,,NSAttributedString非常非常简单\N{\fs14}And an NSAttributedString, very, very simple.
Dialogue: 0,0:59:40.32,0:59:44.16,冬青黑体简体中文,,0,0,0,,它很像… 它不是NSString 但它很像NSString\N{\fs14}It's like -- it is not an NSString -- but it's like an NSString
Dialogue: 0,0:59:44.16,0:59:47.37,冬青黑体简体中文,,0,0,0,,每个字符都有一个属性字典\N{\fs14}where every character has a dictionary of attributes.
Dialogue: 0,0:59:47.37,0:59:52.74,冬青黑体简体中文,,0,0,0,,这些属性诸如下划线 描边宽度 字体等等\N{\fs14}And those attributes are like underlined, or stroke width, font, etc. Okay?
Dialogue: 0,0:59:52.74,0:59:57.45,冬青黑体简体中文,,0,0,0,,我说它很像NSString是因为 它不是NSString的子类\N{\fs14}Now, the reason I say it's like NSString -- it's not a subclass of NSString.
Dialogue: 0,0:59:57.45,1:00:00.16,冬青黑体简体中文,,0,0,0,,你不能将字符串消息发送给它\N{\fs14}You cannot send it string messages.
Dialogue: 0,1:00:01.46,1:00:04.58,冬青黑体简体中文,,0,0,0,,这是一个很重大的限制\N{\fs14}So that seems like a significant restriction. And it is,
Dialogue: 0,1:00:04.58,1:00:07.39,冬青黑体简体中文,,0,0,0,,等下我们会谈到如何处理它\N{\fs14}and we'll talk about how we're going to deal with that in a second.
Dialogue: 0,1:00:07.39,1:00:10.99,冬青黑体简体中文,,0,0,0,,设置属性可以仅仅通过调用…\N{\fs14}You set the attributes simply by calling --
Dialogue: 0,1:00:10.99,1:00:13.67,冬青黑体简体中文,,0,0,0,,抱歉 这是NSAttributedString\N{\fs14}sorry, this is NSAttributedString.
Dialogue: 0,1:00:13.67,1:00:16.51,冬青黑体简体中文,,0,0,0,,它是不可变的 不可修改\N{\fs14}It's immutable -- immutable -- not modifiable.
Dialogue: 0,1:00:16.51,1:00:19.83,冬青黑体简体中文,,0,0,0,,所以NSAttributedString的属性无法设置\N{\fs14}So you cannot set the attributes of an NSAttributedString.
Dialogue: 0,1:00:19.83,1:00:22.46,冬青黑体简体中文,,0,0,0,,还有可变的带属性字符串 等下我会讲到\N{\fs14}There is a mutable attributed string; we'll talk about that in a second.
Dialogue: 0,1:00:22.46,1:00:25.99,冬青黑体简体中文,,0,0,0,,获得属性可以通过调用attributesAtIndex:\N{\fs14}So you get the attributes by calling attributes at index.
Dialogue: 0,1:00:25.99,1:00:27.76,冬青黑体简体中文,,0,0,0,,它会返回一个字典给你\N{\fs14}And it will return you a dictionary
Dialogue: 0,1:00:27.76,1:00:30.29,冬青黑体简体中文,,0,0,0,,包含这一下标处字符的所有属性\N{\fs14}with all the attributes for the character at that index.
Dialogue: 0,1:00:30.29,1:00:31.88,冬青黑体简体中文,,0,0,0,,而这个NSRangePointer\N{\fs14}And that NSRangePointer,
Dialogue: 0,1:00:31.88,1:00:34.42,冬青黑体简体中文,,0,0,0,,如果你传递一个指针给一个range struct\N{\fs14}if you pass it a pointer to a range struct,
Dialogue: 0,1:00:34.42,1:00:40.11,冬青黑体简体中文,,0,0,0,,它会用"多少字符具有完全相同的属性"来填充它\N{\fs14}it will fill it in with "How many characters have the exact same attributes?"
Dialogue: 0,1:00:40.11,1:00:44.23,冬青黑体简体中文,,0,0,0,,它这里是在明确你想要属性的位置\N{\fs14}So it's basically you specify the location that you want the attributes
Dialogue: 0,1:00:44.23,1:00:46.79,冬青黑体简体中文,,0,0,0,,如果很多字符具有这种属性\N{\fs14}and if a whole bunch of characters have those exact same attributes,
Dialogue: 0,1:00:46.79,1:00:49.42,冬青黑体简体中文,,0,0,0,,它会返回这个范围 如果你要求的话\N{\fs14}it will return that range if you ask it.
Dialogue: 0,1:00:49.44,1:00:52.23,冬青黑体简体中文,,0,0,0,,能理解吗 这个范围是什么\N{\fs14}Does that make sense, what that range is?
Dialogue: 0,1:00:52.23,1:00:54.82,冬青黑体简体中文,,0,0,0,,它告诉你 多少字符具有\N{\fs14}It's basically just telling you how many characters have the
Dialogue: 0,1:00:54.82,1:00:57.98,冬青黑体简体中文,,0,0,0,,你要询问的字符处的属性\N{\fs14}attributes you asked for at that character.
Dialogue: 0,1:00:57.98,1:01:00.86,冬青黑体简体中文,,0,0,0,,如果你不关心 你可以传递null\N{\fs14}You can pass null if you don't care and just want
Dialogue: 0,1:01:00.86,1:01:03.03,冬青黑体简体中文,,0,0,0,,只想知道那个字符的属性\N{\fs14}to know the attributes of that character.
Dialogue: 0,1:01:03.03,1:01:06.28,冬青黑体简体中文,,0,0,0,,NSAttributedString不是字符串\N{\fs14}So NSAttributedString is not a string.
Dialogue: 0,1:01:06.28,1:01:08.86,冬青黑体简体中文,,0,0,0,,但我们希望做类似字符串的事情\N{\fs14}But we want to do string-like things.
Dialogue: 0,1:01:08.86,1:01:13.11,冬青黑体简体中文,,0,0,0,,我们希望搜索其它子字符串 做这类能对字符串做的事情\N{\fs14}We want to search for other substrings and things like that, that we do on a string.
Dialogue: 0,1:01:13.11,1:01:15.86,冬青黑体简体中文,,0,0,0,,所以NSAttributedString中有一个方法\N{\fs14}So there's a method in NSAttributedString --
Dialogue: 0,1:01:15.86,1:01:18.21,冬青黑体简体中文,,0,0,0,,它很重要 叫作string\N{\fs14}really important one -- called "string."
Dialogue: 0,1:01:18.21,1:01:22.56,冬青黑体简体中文,,0,0,0,,这会返回一个NSString 你可以进行搜索\N{\fs14}And this will return an NSString that you can then search in
Dialogue: 0,1:01:22.56,1:01:25.31,冬青黑体简体中文,,0,0,0,,做所有能对字符串做的事\N{\fs14}or do all the string things you want.
Dialogue: 0,1:01:25.32,1:01:27.56,冬青黑体简体中文,,0,0,0,,例如 如果你想搜索\N{\fs14}For example, if we wanted to search,
Dialogue: 0,1:01:27.57,1:01:30.16,冬青黑体简体中文,,0,0,0,,NSString中有个方法叫rangeOfString\N{\fs14}there's a method in NSString called "range of string,"
Dialogue: 0,1:01:30.16,1:01:32.16,冬青黑体简体中文,,0,0,0,,它会返回一个NSRange 告诉你\N{\fs14}which returns an NSRange that tells you
Dialogue: 0,1:01:32.16,1:01:35.01,冬青黑体简体中文,,0,0,0,,字符串中子字符串在哪\N{\fs14}where a substring is in a string.
Dialogue: 0,1:01:35.01,1:01:37.50,冬青黑体简体中文,,0,0,0,,我们可以说 我们有一个带属性字符串\N{\fs14}And so we can just say we have an attributed string lying
Dialogue: 0,1:01:37.50,1:01:39.86,冬青黑体简体中文,,0,0,0,,我们要找某个子字符串\N{\fs14}around and we're looking for some substring;
Dialogue: 0,1:01:39.86,1:01:40.60,冬青黑体简体中文,,0,0,0,,我们可以说\N{\fs14}we just say
Dialogue: 0,1:01:40.60,1:01:43.32,冬青黑体简体中文,,0,0,0,,[attributedString string] rangeOfString:substring\N{\fs14}attributed string string, range of string string,
Dialogue: 0,1:01:43.32,1:01:44.77,冬青黑体简体中文,,0,0,0,,返回的将是范围\N{\fs14}and we'll get the range back.
Dialogue: 0,1:01:44.77,1:01:50.55,冬青黑体简体中文,,0,0,0,,这个string方法保证能具有高性能\N{\fs14}Now, that string method is guaranteed to be very high performance
Dialogue: 0,1:01:50.55,1:01:52.26,冬青黑体简体中文,,0,0,0,,因为你会一直做这个\N{\fs14}because you're doing this all the time.
Dialogue: 0,1:01:52.26,1:01:55.51,冬青黑体简体中文,,0,0,0,,你希望像字符串那样处理NSAttributedString\N{\fs14}You want to look at the NSAttributedString like a string.
Dialogue: 0,1:01:55.51,1:01:56.77,冬青黑体简体中文,,0,0,0,,它是高性能的\N{\fs14}So it's high performance.
Dialogue: 0,1:01:56.77,1:01:58.90,冬青黑体简体中文,,0,0,0,,但是 它又是容易丢失的\N{\fs14}However, it's also volatile.
Dialogue: 0,1:01:58.90,1:02:01.94,冬青黑体简体中文,,0,0,0,,结果 这个返回的指针可能指向\N{\fs14}The bottom line is this thing is probably returning you a pointer
Dialogue: 0,1:02:01.94,1:02:04.79,冬青黑体简体中文,,0,0,0,,那个NSAttributedString的内部数据结构\N{\fs14}to that NSAttributedStrings' internal data structure,
Dialogue: 0,1:02:04.79,1:02:06.66,冬青黑体简体中文,,0,0,0,,或它的某一部分 这之类\N{\fs14}or some parts of it, or something.
Dialogue: 0,1:02:06.66,1:02:08.18,冬青黑体简体中文,,0,0,0,,你不知道具体是什么\N{\fs14}You don't really know what it is.
Dialogue: 0,1:02:08.18,1:02:11.34,冬青黑体简体中文,,0,0,0,,你知道返回的是一个NSString 但是…\N{\fs14}You know whatever it returns is an NSString. But
Dialogue: 0,1:02:11.34,1:02:16.40,冬青黑体简体中文,,0,0,0,,如果你想保留这个 不仅用于你所调用的地方\N{\fs14}so if you want to keep that thing around for more than just right there where you call it,
Dialogue: 0,1:02:16.40,1:02:17.85,冬青黑体简体中文,,0,0,0,,你可以复制一份\N{\fs14}make a copy of it.
Dialogue: 0,1:02:17.85,1:02:20.85,冬青黑体简体中文,,0,0,0,,这样你就有了NSString的一个副本 可以存储下来\N{\fs14}Then you have a copy of the NSString. You can hold onto it.
Dialogue: 0,1:02:20.85,1:02:22.36,冬青黑体简体中文,,0,0,0,,你几乎从来不需要这样做 因为\N{\fs14}You almost never need to do that because you're almost
Dialogue: 0,1:02:22.36,1:02:25.79,冬青黑体简体中文,,0,0,0,,你基本总会在此时此地处理字符串\N{\fs14}always operating on the string right there in place like this --
Dialogue: 0,1:02:25.79,1:02:26.62,冬青黑体简体中文,,0,0,0,,字符串的范围\N{\fs14}a range of string.
Dialogue: 0,1:02:26.62,1:02:27.86,冬青黑体简体中文,,0,0,0,,你尝试得到它\N{\fs14}You're just trying to get it.
Dialogue: 0,1:02:29.62,1:02:31.71,冬青黑体简体中文,,0,0,0,,这是字符串 NSString中很重要的属性\N{\fs14}So that's string. Very important property in NSString.
Dialogue: 0,1:02:31.71,1:02:33.37,冬青黑体简体中文,,0,0,0,,还有一个可变版本\N{\fs14}So there is a mutable one.
Dialogue: 0,1:02:33.37,1:02:41.17,冬青黑体简体中文,,0,0,0,,可变版本继承自不可变的带属性字符串\N{\fs14}And mutable one, it does inherit from the nonmutable attributed string.
Dialogue: 0,1:02:41.17,1:02:43.81,冬青黑体简体中文,,0,0,0,,但它不是NSString 或NSMutableString\N{\fs14}But it's not an NSString or an NSMutableString.
Dialogue: 0,1:02:43.81,1:02:46.14,冬青黑体简体中文,,0,0,0,,它是一种NSAttributedString\N{\fs14}It's an NSAttributedString.
Dialogue: 0,1:02:46.14,1:02:49.65,冬青黑体简体中文,,0,0,0,,它添加了增加属性和设置属性方法\N{\fs14}And it adds these methods to add attributes and set attributes
Dialogue: 0,1:02:49.65,1:02:53.99,冬青黑体简体中文,,0,0,0,,在带属性字符串中的各种范围内\N{\fs14}at various ranges inside the attributed string.
Dialogue: 0,1:02:53.99,1:02:55.82,冬青黑体简体中文,,0,0,0,,这很容易理解\N{\fs14}Exactly what you would think.
Dialogue: 0,1:02:55.82,1:02:59.42,冬青黑体简体中文,,0,0,0,,几张幻灯片以后 我会讲到这些字典中都有什么\N{\fs14}And we're going to talk about what's in these dictionaries in a couple slides.
Dialogue: 0,1:02:59.42,1:03:05.34,冬青黑体简体中文,,0,0,0,,如果想要修改可变带属性字符串中的字符该怎么做\N{\fs14}Now, what if you want to modify the characters in a mutable attributed string?
Dialogue: 0,1:03:05.34,1:03:08.80,冬青黑体简体中文,,0,0,0,,同带属性字符串一样\N{\fs14}Exact same thing as the attributed string.
Dialogue: 0,1:03:08.80,1:03:12.69,冬青黑体简体中文,,0,0,0,,当你考虑字符时 你可以调用mutableString方法\N{\fs14}When you want to look at the characters, you call this method mutable string.
Dialogue: 0,1:03:12.69,1:03:14.74,冬青黑体简体中文,,0,0,0,,它会返回一个NSMutableString\N{\fs14}And it will return an NSMutableString.
Dialogue: 0,1:03:14.74,1:03:18.73,冬青黑体简体中文,,0,0,0,,信不信由你 如果你修改这个可变字符串\N{\fs14}And believe it or not, if you modify that mutable string
Dialogue: 0,1:03:18.73,1:03:24.30,冬青黑体简体中文,,0,0,0,,回到可变带属性字符串 其属性会追踪你的变化\N{\fs14}that you get back, the mutable attributed string, its attributes will track your changes.
Dialogue: 0,1:03:24.30,1:03:28.02,冬青黑体简体中文,,0,0,0,,例如 如果你插入一些文本 新文本将获得\N{\fs14}So like, if you insert some text, the new text will get the attributes
Dialogue: 0,1:03:28.02,1:03:30.74,冬青黑体简体中文,,0,0,0,,插入处字符的属性\N{\fs14}of the character right where you inserted it.
Dialogue: 0,1:03:30.74,1:03:34.04,冬青黑体简体中文,,0,0,0,,如果你将字符从可变字符串中删除\N{\fs14}If you delete characters out of that mutable string,
Dialogue: 0,1:03:34.04,1:03:38.34,冬青黑体简体中文,,0,0,0,,那么在可变带属性字符串中 那些字符属性也会消失\N{\fs14}then the mutable attributed string, those character attributes will just go away.
Dialogue: 0,1:03:38.34,1:03:39.40,冬青黑体简体中文,,0,0,0,,明白吗\N{\fs14}Make sense?
Dialogue: 0,1:03:39.40,1:03:41.30,冬青黑体简体中文,,0,0,0,,这些类\N{\fs14}So these classes --
Dialogue: 0,1:03:41.30,1:03:44.06,冬青黑体简体中文,,0,0,0,,NSMutableString和NSMutableAttributedString\N{\fs14}NSMutableString and NSMutableAttributedString --
Dialogue: 0,1:03:44.06,1:03:46.92,冬青黑体简体中文,,0,0,0,,相互联系起来 关系就像NSAttributedString\N{\fs14}are in bed with each other, just like NSAttributedString
Dialogue: 0,1:03:46.92,1:03:48.47,冬青黑体简体中文,,0,0,0,,和NSString之间一样\N{\fs14}and NSString are in bed with each other.
Dialogue: 0,1:03:48.47,1:03:51.23,冬青黑体简体中文,,0,0,0,,我不知道苹果是怎么做到的\N{\fs14}I don't know how they did it at Apple,
Dialogue: 0,1:03:51.23,1:03:53.07,冬青黑体简体中文,,0,0,0,,不过这很棒 因为\N{\fs14}but it's really nice because it makes it really easy
Dialogue: 0,1:03:53.07,1:03:59.71,冬青黑体简体中文,,0,0,0,,字符和带属性字符串中的属性都很容易操作\N{\fs14}to manipulate both the characters and the attributes in an attributed string.
Dialogue: 0,1:03:59.71,1:04:03.61,冬青黑体简体中文,,0,0,0,,好 那这些属性字典中都有些什么属性呢\N{\fs14}Okay. So what kind of attributes are in those attributes dictionaries?
Dialogue: 0,1:04:03.61,1:04:06.30,冬青黑体简体中文,,0,0,0,,一个重要的是字体\N{\fs14}One of the big ones is the font.
Dialogue: 0,1:04:06.30,1:04:08.72,冬青黑体简体中文,,0,0,0,,这是一个字典\N{\fs14}So this is a dictionary.
Dialogue: 0,1:04:08.72,1:04:11.89,冬青黑体简体中文,,0,0,0,,字体的键是NSFontAttributeName\N{\fs14}The key for the font is NSFontAttributeName.
Dialogue: 0,1:04:11.89,1:04:14.74,冬青黑体简体中文,,0,0,0,,你们可以去查下这些键\N{\fs14}And you can look up these keys by going and looking --
Dialogue: 0,1:04:14.74,1:04:20.04,冬青黑体简体中文,,0,0,0,,NSAttributedString在说明文档中有一个链接\N{\fs14}if you look up NSAttributedString in the documentation, there's a link there,
Dialogue: 0,1:04:20.04,1:04:23.26,冬青黑体简体中文,,0,0,0,,也就是NSAttributedString的UIKit增添部分\N{\fs14}which is UIkit additions to NSAttributedString,
Dialogue: 0,1:04:23.26,1:04:25.65,冬青黑体简体中文,,0,0,0,,我要讲的所有键都在这里有\N{\fs14}and all the keys that I'm going to talk about are there.
Dialogue: 0,1:04:25.65,1:04:28.38,冬青黑体简体中文,,0,0,0,,其中一个键就是NSFontAttributeName\N{\fs14}And one of the keys is NSFontAttributeName.
Dialogue: 0,1:04:28.38,1:04:32.90,冬青黑体简体中文,,0,0,0,,其值是UIFont\N{\fs14}And the value of that is a UIFont.
Dialogue: 0,1:04:32.90,1:04:36.39,冬青黑体简体中文,,0,0,0,,这就是获得特定样式首选字体的地方\N{\fs14}So this is where you would get a preferred font of a certain style,
Dialogue: 0,1:04:36.40,1:04:38.40,冬青黑体简体中文,,0,0,0,,例如这里是标题\N{\fs14}like a headline, let's say, in this case.
Dialogue: 0,1:04:39.60,1:04:43.15,冬青黑体简体中文,,0,0,0,,如果我的字典中只有这个\N{\fs14}So if I had a dictionary that just had this in there --
Dialogue: 0,1:04:43.15,1:04:45.88,冬青黑体简体中文,,0,0,0,,没有别的 默认文本颜色是黑色\N{\fs14}nothing else -- the default text color is black.
Dialogue: 0,1:04:45.88,1:04:49.25,冬青黑体简体中文,,0,0,0,,也许我的A会是这样的\N{\fs14}Probably my letter A would like look that.
Dialogue: 0,1:04:49.25,1:04:53.58,冬青黑体简体中文,,0,0,0,,如果我将这个键值对加到我的字典呢\N{\fs14}What if I added this key value pair to my dictionary?
Dialogue: 0,1:04:53.58,1:04:55.60,冬青黑体简体中文,,0,0,0,,NSForegroundColorAttributeName :\N{\fs14}NS Foreground Color Attribute Name,
Dialogue: 0,1:04:55.60,1:04:57.45,冬青黑体简体中文,,0,0,0,,[UIColor blueColor]\N{\fs14}UIColor, blue color. So
Dialogue: 0,1:04:57.47,1:04:59.69,冬青黑体简体中文,,0,0,0,,这里的键是NSForegroundColorAttributeName\N{\fs14}here the key is this foreground color attribute name;
Dialogue: 0,1:04:59.69,1:05:01.38,冬青黑体简体中文,,0,0,0,,值是UIColor\N{\fs14}the value is a UIColor.
Dialogue: 0,1:05:01.38,1:05:03.00,冬青黑体简体中文,,0,0,0,,这将它换成蓝色\N{\fs14}So that changed it to blue.
Dialogue: 0,1:05:03.00,1:05:06.11,冬青黑体简体中文,,0,0,0,,我还可以将它换成绿色\N{\fs14}Okay. And I could change it to green if I wanted to.
Dialogue: 0,1:05:06.11,1:05:10.88,冬青黑体简体中文,,0,0,0,,创建具有颜色文本的带属性字符串时要小心\N{\fs14}Be a little bit careful when you create an attributed string that has colored text
Dialogue: 0,1:05:10.88,1:05:15.64,冬青黑体简体中文,,0,0,0,,因为在iOS7中 文本颜色有时是一个指示器\N{\fs14}because in iOS 7 the color of text sometimes is an indicator
Dialogue: 0,1:05:15.64,1:05:18.46,冬青黑体简体中文,,0,0,0,,告诉终端用户他们能够触摸什么\N{\fs14}to the end user what they can touch.
Dialogue: 0,1:05:18.46,1:05:26.56,冬青黑体简体中文,,0,0,0,,iOS的app中有一个颜色主题 默认是蓝色\N{\fs14}And so if -- turns out apps in iOS kind of have a color theme. The default is blue.
Dialogue: 0,1:05:26.56,1:05:31.25,冬青黑体简体中文,,0,0,0,,所以Machismo的按钮我们用的是蓝色\N{\fs14}That's why on Machismo buttons that we make will be blue.
Dialogue: 0,1:05:31.25,1:05:34.10,冬青黑体简体中文,,0,0,0,,不过也可以是别的颜色 例如橙色\N{\fs14}But they can be different colors like orange.
Dialogue: 0,1:05:34.10,1:05:36.50,冬青黑体简体中文,,0,0,0,,这取决于你想要怎样的色彩\N{\fs14}It depends on what tint you want your thing to be.
Dialogue: 0,1:05:36.50,1:05:41.98,冬青黑体简体中文,,0,0,0,,这些颜色通常就是暗示能够触击\N{\fs14}But whatever your color is of your app, that color you can usually tap on.
Dialogue: 0,1:05:41.98,1:05:47.19,冬青黑体简体中文,,0,0,0,,这是按钮上文本的颜色 用于链接的文字的颜色\N{\fs14}Okay. That's the color of text on buttons, text at the top of the screen to navigate places.
Dialogue: 0,1:05:47.19,1:05:52.35,冬青黑体简体中文,,0,0,0,,所以你要小心 不要将不能触击的文本设置为这种颜色\N{\fs14}So be careful not to set anything else to be that color unless you can tap on it.
Dialogue: 0,1:05:52.35,1:05:54.79,冬青黑体简体中文,,0,0,0,,颜色上你需要很小心\N{\fs14}Be real careful with color.
Dialogue: 0,1:05:54.79,1:05:58.12,冬青黑体简体中文,,0,0,0,,还有描边宽度属性 以及描边颜色\N{\fs14}There's also stroke width attribute and stroke color.
Dialogue: 0,1:05:58.12,1:06:02.23,冬青黑体简体中文,,0,0,0,,宽度属性 注意这个 因为以后在作业中\N{\fs14}The width attribute -- and pay attention to this because you'll need this probably
Dialogue: 0,1:06:02.23,1:06:06.33,冬青黑体简体中文,,0,0,0,,你们可能会需要 这是一个NSNumber\N{\fs14}for your homework -- it's an NSNumber.
Dialogue: 0,1:06:06.33,1:06:13.39,冬青黑体简体中文,,0,0,0,,如果是负NSNumber 那就意味着填充字形\N{\fs14}If it's a negative NSNumber, then that means fill glyph,
Dialogue: 0,1:06:13.39,1:06:16.52,冬青黑体简体中文,,0,0,0,,这里也就是填充A 并描边\N{\fs14}you know, the A fill it, and stroke around the edge.
Dialogue: 0,1:06:16.52,1:06:19.86,冬青黑体简体中文,,0,0,0,,如果是正数 那就意味着只描边\N{\fs14}If it's a positive number, it means just do the stroke around the edge
Dialogue: 0,1:06:19.86,1:06:22.31,冬青黑体简体中文,,0,0,0,,而中间则是透明的\N{\fs14}and the middle is transparent.
Dialogue: 0,1:06:23.67,1:06:25.71,冬青黑体简体中文,,0,0,0,,看看还有什么\N{\fs14}What else can we have?
Dialogue: 0,1:06:25.71,1:06:27.49,冬青黑体简体中文,,0,0,0,,下划线样式属性名\N{\fs14}Underline style attribute name.
Dialogue: 0,1:06:27.49,1:06:29.85,冬青黑体简体中文,,0,0,0,,这是一个NSNumber 它具有一个enum\N{\fs14}So that's an NSNumber that has an enum,
Dialogue: 0,1:06:29.85,1:06:32.61,冬青黑体简体中文,,0,0,0,,有NSUnderlineStyleSingle或Double\N{\fs14}one of NS style underline style single or double.
Dialogue: 0,1:06:32.61,1:06:35.16,冬青黑体简体中文,,0,0,0,,还有NSUnderlineStyleNone\N{\fs14}Or there's also NS underline style none.
Dialogue: 0,1:06:35.16,1:06:36.75,冬青黑体简体中文,,0,0,0,,表示没有下划线\N{\fs14}That would be no underlining.
Dialogue: 0,1:06:36.75,1:06:38.80,冬青黑体简体中文,,0,0,0,,然后还有背景颜色\N{\fs14}There's also background color.
Dialogue: 0,1:06:38.80,1:06:41.28,冬青黑体简体中文,,0,0,0,,这里是想告诉你们 这是可以的\N{\fs14}So here just to show you this is possible,
Dialogue: 0,1:06:41.28,1:06:46.52,冬青黑体简体中文,,0,0,0,,我将这个字形的背景设为了透明黄色\N{\fs14}I set the background of this glyph to be a transparent yellow.
Dialogue: 0,1:06:46.52,1:06:52.10,冬青黑体简体中文,,0,0,0,,它是透明度为30%的黄色\N{\fs14}It's thirty percent visible, thirty percent towards opaque yellow.
Dialogue: 0,1:06:52.12,1:06:55.27,冬青黑体简体中文,,0,0,0,,所以这里可以看到黑板的颜色\N{\fs14}So you see how you can see the chalkboard shown through there?
Dialogue: 0,1:06:55.27,1:06:59.10,冬青黑体简体中文,,0,0,0,,我不知道iTunes U视频中显得得如何 你们应该能够看得出\N{\fs14}I don't know if that will show up on iTunes U. But here hopefully you can see --
Dialogue: 0,1:06:59.10,1:07:02.54,冬青黑体简体中文,,0,0,0,,我可以看到黄色背景后的东西\N{\fs14}I can see through that yellow background.
Dialogue: 0,1:07:02.54,1:07:05.27,冬青黑体简体中文,,0,0,0,,你们在作业中 也应该\N{\fs14}In your homework, you might want to think
Dialogue: 0,1:07:05.27,1:07:07.66,冬青黑体简体中文,,0,0,0,,尝试用一下透明色\N{\fs14}about using transparent colors somewhere else.
Dialogue: 0,1:07:07.66,1:07:10.99,冬青黑体简体中文,,0,0,0,,不是字符背景 而是填充颜色这些\N{\fs14}Okay. Not the background of a character or maybe the fill color or something.
Dialogue: 0,1:07:10.99,1:07:12.19,冬青黑体简体中文,,0,0,0,,不管怎样\N{\fs14}Anyway, okay.
Dialogue: 0,1:07:12.19,1:07:14.29,冬青黑体简体中文,,0,0,0,,透明色很好\N{\fs14}So transparent color's good.
Dialogue: 0,1:07:14.29,1:07:16.10,冬青黑体简体中文,,0,0,0,,但愿你们都感受到了\N{\fs14}Okay. So hopefully you're all getting a feel, then,
Dialogue: 0,1:07:16.10,1:07:17.83,冬青黑体简体中文,,0,0,0,,我们是如何构建这个字典的\N{\fs14}for how we build this dictionary.
Dialogue: 0,1:07:17.83,1:07:20.93,冬青黑体简体中文,,0,0,0,,我们只需要设置字符的属性\N{\fs14}Okay. All we need to do is set the attributes of the characters
Dialogue: 0,1:07:20.93,1:07:25.60,冬青黑体简体中文,,0,0,0,,设置为我们所希望设定的这一系列属性\N{\fs14}that we want to have this particular set of attributes.
Dialogue: 0,1:07:25.60,1:07:27.93,冬青黑体简体中文,,0,0,0,,我们在哪使用带属性字符串呢\N{\fs14}So where do we use attributed strings?
Dialogue: 0,1:07:27.93,1:07:29.85,冬青黑体简体中文,,0,0,0,,我可以创建一个带属性字符串\N{\fs14}So I can create an attributed string.
Dialogue: 0,1:07:29.85,1:07:31.25,冬青黑体简体中文,,0,0,0,,它有所有这些属性\N{\fs14}It's got all these attributes.
Dialogue: 0,1:07:31.25,1:07:32.67,冬青黑体简体中文,,0,0,0,,在哪使用它呢\N{\fs14}Okay. Where do I use it?
Dialogue: 0,1:07:32.67,1:07:34.70,冬青黑体简体中文,,0,0,0,,我可以在按钮上使用它\N{\fs14}Well, I can use it in a button.
Dialogue: 0,1:07:34.70,1:07:37.63,冬青黑体简体中文,,0,0,0,,我可以设置按钮的标题为带属性字符串\N{\fs14}Okay. I can set the title of a button to be an attributed string.
Dialogue: 0,1:07:37.63,1:07:40.75,冬青黑体简体中文,,0,0,0,,这对你们的作业可能会有好处\N{\fs14}That might be useful for your homework.
Dialogue: 0,1:07:40.75,1:07:44.17,冬青黑体简体中文,,0,0,0,,我们可以创建一个具有带属性字符串的UILabel\N{\fs14}We can create a UI label that has an attributed string.
Dialogue: 0,1:07:44.17,1:07:48.11,冬青黑体简体中文,,0,0,0,,还有一个很重要的类 也许下次我会讲到\N{\fs14}And a very important class, which I'm probably going to talk about next time,
Dialogue: 0,1:07:48.11,1:07:50.06,冬青黑体简体中文,,0,0,0,,也就是UITextView\N{\fs14}which is UITextView.
Dialogue: 0,1:07:50.06,1:07:52.24,冬青黑体简体中文,,0,0,0,,UITextView类似于UILabel\N{\fs14}UITextView is like a UILabel,
Dialogue: 0,1:07:52.24,1:07:57.17,冬青黑体简体中文,,0,0,0,,但它可编辑 可选择 可滚动等等\N{\fs14}but it's editable, selectable, scrollable, etc. Okay?
Dialogue: 0,1:07:57.17,1:07:59.47,冬青黑体简体中文,,0,0,0,,我们来看一下按钮\N{\fs14}So let's talk about button.
Dialogue: 0,1:07:59.47,1:08:02.84,冬青黑体简体中文,,0,0,0,,实际上 我不打算详细讲按钮\N{\fs14}Actually, I'm not going to talk about button,
Dialogue: 0,1:08:02.84,1:08:06.16,冬青黑体简体中文,,0,0,0,,我只想说 它对你们的作业很重要\N{\fs14}except for to say it's important for your homework.
Dialogue: 0,1:08:06.16,1:08:10.65,冬青黑体简体中文,,0,0,0,,它有一个方法setAttributedTitle:\N{\fs14}It just has a method -- set attributed title --
Dialogue: 0,1:08:10.65,1:08:12.78,冬青黑体简体中文,,0,0,0,,就像setTitle: forState:一样\N{\fs14}just like it has set title for a state,
Dialogue: 0,1:08:12.78,1:08:14.25,冬青黑体简体中文,,0,0,0,,这里有setAttributedTitle: forState:\N{\fs14}it has set attributed title for state.
Dialogue: 0,1:08:14.25,1:08:16.60,冬青黑体简体中文,,0,0,0,,你会用到这个\N{\fs14}And you're going to want to use that.
Dialogue: 0,1:08:16.60,1:08:20.83,冬青黑体简体中文,,0,0,0,,还有可能直接在屏幕上绘制字符串\N{\fs14}It's also possible to draw strings directly on screen.
Dialogue: 0,1:08:20.83,1:08:23.56,冬青黑体简体中文,,0,0,0,,不过我们还没讨论到直接在屏幕上绘制\N{\fs14}But we haven't talked about drawing on screen directly yet.
Dialogue: 0,1:08:23.56,1:08:26.61,冬青黑体简体中文,,0,0,0,,这部分内容我们将推迟到下周\N{\fs14}So we'll postpone until we talk about that next week.
Dialogue: 0,1:08:26.61,1:08:30.26,冬青黑体简体中文,,0,0,0,,不过我们是能够直接在屏幕上绘制带属性字符串的\N{\fs14}But we will be able to draw attributed strings on screens directly,
Dialogue: 0,1:08:30.26,1:08:35.24,冬青黑体简体中文,,0,0,0,,就像我们能够直接在屏幕上绘制直线这些一样\N{\fs14}just like we can draw lines and things like that directly on screen.
Dialogue: 0,1:08:35.24,1:08:38.00,冬青黑体简体中文,,0,0,0,,UILabel有一个属性\N{\fs14}UILabel has a property,
Dialogue: 0,1:08:38.00,1:08:39.79,冬青黑体简体中文,,0,0,0,,它是一个NSAttributedString 叫作\N{\fs14}it's an NSAttributedString called
Dialogue: 0,1:08:39.79,1:08:41.07,冬青黑体简体中文,,0,0,0,,attributedText\N{\fs14}"attributed text."
Dialogue: 0,1:08:41.07,1:08:43.85,冬青黑体简体中文,,0,0,0,,就像文本标签 这是一个NSString\N{\fs14}It's just like the text label, which is an NSString,
Dialogue: 0,1:08:43.85,1:08:45.59,冬青黑体简体中文,,0,0,0,,我们已经使用过这个\N{\fs14}which we've already used in this class,
Dialogue: 0,1:08:45.59,1:08:48.07,冬青黑体简体中文,,0,0,0,,例如分数标签和翻牌计数标签\N{\fs14}we like the score label and the flips label.
Dialogue: 0,1:08:48.07,1:08:49.40,冬青黑体简体中文,,0,0,0,,我们设置了文本属性\N{\fs14}We set the text property.
Dialogue: 0,1:08:49.40,1:08:51.36,冬青黑体简体中文,,0,0,0,,这里有一个带属性的文本属性\N{\fs14}So there's an attributed text property.
Dialogue: 0,1:08:51.36,1:08:54.99,冬青黑体简体中文,,0,0,0,,你通过NSAttributedString 而非NSString设置属性\N{\fs14}And you just set the property via an NSAttributedString instead of an NSString.
Dialogue: 0,1:08:54.99,1:08:55.83,冬青黑体简体中文,,0,0,0,,就是这样了\N{\fs14}And that's it.
Dialogue: 0,1:08:55.83,1:08:58.07,冬青黑体简体中文,,0,0,0,,很不幸 它是只读的\N{\fs14}Unfortunately, it's read-only.
Dialogue: 0,1:08:58.07,1:08:59.79,冬青黑体简体中文,,0,0,0,,它是不可变的\N{\fs14}Okay. It's immutable.
Dialogue: 0,1:08:59.79,1:09:02.66,冬青黑体简体中文,,0,0,0,,该属性不是NSMutableAttributedString\N{\fs14}That property you see is not an NS Mutable Attributed String;
Dialogue: 0,1:09:02.66,1:09:04.13,冬青黑体简体中文,,0,0,0,,它只是NSAttributedString\N{\fs14}it's an NSAttributedString.
Dialogue: 0,1:09:04.13,1:09:07.72,冬青黑体简体中文,,0,0,0,,如果你希望改变UILabel上的带属性文本\N{\fs14}So if you want to change the attributed text that's on a UILabel,
Dialogue: 0,1:09:07.72,1:09:11.19,冬青黑体简体中文,,0,0,0,,你需要获取标签 复制它得到一个可变副本\N{\fs14}you have to get the label, make a mutable copy of it,
Dialogue: 0,1:09:11.19,1:09:14.19,冬青黑体简体中文,,0,0,0,,按要求修改它 再将它放回去\N{\fs14}modify it however you want, and put it back.
Dialogue: 0,1:09:14.19,1:09:16.50,冬青黑体简体中文,,0,0,0,,如果你有一个已有标签\N{\fs14}Okay. That's if you have an existing label and you want
Dialogue: 0,1:09:16.50,1:09:19.62,冬青黑体简体中文,,0,0,0,,你想把它变成蓝色 而非绿色 诸如此类\N{\fs14}to make it be blue instead of green or something like that.
Dialogue: 0,1:09:19.62,1:09:22.46,冬青黑体简体中文,,0,0,0,,你需要获取它 创建一个可变副本\N{\fs14}You have to get it, create a mutable copy,
Dialogue: 0,1:09:22.46,1:09:25.58,冬青黑体简体中文,,0,0,0,,修改属性 再将它放回去\N{\fs14}modify the attributes, put it back.
Dialogue: 0,1:09:27.31,1:09:29.71,冬青黑体简体中文,,0,0,0,,标签上 你不需要经常这样做\N{\fs14}You don't need to do this very often on labels.
Dialogue: 0,1:09:29.71,1:09:33.27,冬青黑体简体中文,,0,0,0,,标签上不会经常出现带属性文本\N{\fs14}Labels don't really have attributed text on them that much.
Dialogue: 0,1:09:33.27,1:09:35.19,冬青黑体简体中文,,0,0,0,,也许是设置颜色\N{\fs14}Maybe to set the color.
Dialogue: 0,1:09:35.19,1:09:39.02,冬青黑体简体中文,,0,0,0,,也许 如果有一些专门标签\N{\fs14}Possibly if they're specialty labels that are kind
Dialogue: 0,1:09:39.02,1:09:41.97,冬青黑体简体中文,,0,0,0,,用于指定并非正常文本的东西\N{\fs14}of specifying something that's not just normal text.
Dialogue: 0,1:09:41.97,1:09:45.27,冬青黑体简体中文,,0,0,0,,所以说 这对UILabel并不那么普遍\N{\fs14}So it's not that common to do UILabel.
Dialogue: 0,1:09:45.27,1:09:52.19,冬青黑体简体中文,,0,0,0,,今天我要讲的也就这些了\N{\fs14}So that's all I'm going to cover for today, I think.
Dialogue: 0,1:09:52.19,1:09:53.79,冬青黑体简体中文,,0,0,0,,周五有一堂讨论课\N{\fs14}We do have a Friday section.
Dialogue: 0,1:09:53.79,1:09:58.81,冬青黑体简体中文,,0,0,0,,时间在我讲课的时候得到了确认\N{\fs14}The time is being confirmed to me probably as I speak right now.
Dialogue: 0,1:09:58.81,1:10:01.74,冬青黑体简体中文,,0,0,0,,我会发布在Piazza上\N{\fs14}I will post that for you on Piazza.
Dialogue: 0,1:10:01.74,1:10:02.77,冬青黑体简体中文,,0,0,0,,时间是周五\N{\fs14}It's on Friday.
Dialogue: 0,1:10:02.77,1:10:07.88,冬青黑体简体中文,,0,0,0,,我记得应该是周五1点在102室\N{\fs14}I believe it's going to be at 1:00 o'clock on Friday in 102. Okay, unit 102.
Dialogue: 0,1:10:07.88,1:10:10.93,冬青黑体简体中文,,0,0,0,,不过不要以我为准 以Piazza为准\N{\fs14}But don't hold me to that yet. Look at Piazza.
Dialogue: 0,1:10:10.95,1:10:13.30,冬青黑体简体中文,,0,0,0,,我们会谈到调试\N{\fs14}We're going to be talking about debugging.
Dialogue: 0,1:10:13.30,1:10:16.53,冬青黑体简体中文,,0,0,0,,iOS7有一些新的调试内容 它们非常酷\N{\fs14}There are some new debugging things for iOS 7 that are pretty cool.
Dialogue: 0,1:10:16.53,1:10:17.82,冬青黑体简体中文,,0,0,0,,我们会讲到一些\N{\fs14}We'll get to a couple of them.
Dialogue: 0,1:10:17.82,1:10:20.42,冬青黑体简体中文,,0,0,0,,我还将讲到Xcode的一些要诀和技巧\N{\fs14}And we're also going to talk about Xcode tips and tricks.
Dialogue: 0,1:10:20.42,1:10:23.43,冬青黑体简体中文,,0,0,0,,Command键组合非常有价值\N{\fs14}So command key combinations that are really valuable to have,
Dialogue: 0,1:10:23.43,1:10:27.31,冬青黑体简体中文,,0,0,0,,如何设置偏好 让你的体验更好一些\N{\fs14}how to set some preferences up to make your experience a little nicer.
Dialogue: 0,1:10:27.31,1:10:29.39,冬青黑体简体中文,,0,0,0,,这些都是可选的 不要求大家一定到课\N{\fs14}So it's totally optional. You don't need to go there.
Dialogue: 0,1:10:29.39,1:10:30.59,冬青黑体简体中文,,0,0,0,,很多人很了解Xcode\N{\fs14}A lot of you know Xcode.
Dialogue: 0,1:10:30.59,1:10:34.15,冬青黑体简体中文,,0,0,0,,也很熟悉调试 至少在其它语言中\N{\fs14}You're probably used to debugging, at least in other languages.
Dialogue: 0,1:10:34.15,1:10:37.34,冬青黑体简体中文,,0,0,0,,所以 就算没上 也不是世界末日\N{\fs14}So, you know, if you miss it, it's not going to be the end the world.
Dialogue: 0,1:10:37.34,1:10:39.20,冬青黑体简体中文,,0,0,0,,不过这可能会有价值\N{\fs14}But it might be valuable.
Dialogue: 0,1:10:39.20,1:10:41.81,冬青黑体简体中文,,0,0,0,,下周一我将讲到UITextView\N{\fs14}Next Monday I'm going to talk about UITextView
Dialogue: 0,1:10:41.82,1:10:47.75,冬青黑体简体中文,,0,0,0,,它是NSMutableAttributedString的最重要使用者\N{\fs14}since it's the most important user of NS Mutable Attributed String.
Dialogue: 0,1:10:47.75,1:10:52.52,冬青黑体简体中文,,0,0,0,,然后我将讲到来自MVC的电台\N{\fs14}And then I'm also going to talk about the radio station from MVC.
Dialogue: 0,1:10:52.52,1:10:53.77,冬青黑体简体中文,,0,0,0,,记得MVC模型吗\N{\fs14}Remember that MVC model?
Dialogue: 0,1:10:53.77,1:10:58.37,冬青黑体简体中文,,0,0,0,,我讲过 有时通信可以通过电台的广播来进行\N{\fs14}I told you that sometimes communication happens by radio station, where you broadcast
Dialogue: 0,1:10:58.37,1:11:01.76,冬青黑体简体中文,,0,0,0,,其它对象收听 我们会讲到这个\N{\fs14}and some other objects tune in. We're going to talk about doing that.
Dialogue: 0,1:11:01.76,1:11:04.57,冬青黑体简体中文,,0,0,0,,然后我有一个大demo 演示带属性字符串\N{\fs14}And then I have a big demo that does attributed strings,
Dialogue: 0,1:11:04.57,1:11:07.10,冬青黑体简体中文,,0,0,0,,文本视图等等所有这些\N{\fs14}and text views, and all that stuff.
Dialogue: 0,1:11:07.10,1:11:10.18,冬青黑体简体中文,,0,0,0,,然后我们将开始谈到视图控制器生命周期\N{\fs14}And then we're going to go start talking about the view controller lifecycle,
Dialogue: 0,1:11:10.19,1:11:12.48,冬青黑体简体中文,,0,0,0,,也就是你的视图控制器\N{\fs14}okay, which is your view controller.
Dialogue: 0,1:11:12.48,1:11:14.17,冬青黑体简体中文,,0,0,0,,首先开始存在\N{\fs14}It comes into existence.
Dialogue: 0,1:11:14.17,1:11:15.52,冬青黑体简体中文,,0,0,0,,它会发生一些事情\N{\fs14}Things happen to it.
Dialogue: 0,1:11:15.52,1:11:19.06,冬青黑体简体中文,,0,0,0,,例如显示在屏幕上 从屏幕上消失 改变大小 等等\N{\fs14}It appears on screen and goes off screen, changes size, things like that.
Dialogue: 0,1:11:19.06,1:11:20.04,冬青黑体简体中文,,0,0,0,,然后它消失\N{\fs14}And then it goes away.
Dialogue: 0,1:11:20.04,1:11:22.30,冬青黑体简体中文,,0,0,0,,从屏幕消失 甚至完全消失\N{\fs14}Okay. It goes off screen and maybe even disappears.
Dialogue: 0,1:11:22.30,1:11:26.10,冬青黑体简体中文,,0,0,0,,这个发生的过程中 你会得到系统的通知\N{\fs14}And as all that happens, you get notified by the system.
Dialogue: 0,1:11:26.10,1:11:28.80,冬青黑体简体中文,,0,0,0,,你需要知道 什么时候获得通知 怎么做\N{\fs14}And it's important to know when you're going to get notified and what to do
Dialogue: 0,1:11:28.80,1:11:30.96,冬青黑体简体中文,,0,0,0,,这些通知在哪\N{\fs14}where in terms of that notification.
Dialogue: 0,1:11:30.96,1:11:33.87,冬青黑体简体中文,,0,0,0,,我们会在周一谈到这些 视图控制器生命周期\N{\fs14}So we'll be talking about that on Monday, view controller lifecycle.
Dialogue: 0,1:11:33.87,1:11:36.15,冬青黑体简体中文,,0,0,0,,它对你们下次作业至关重要\N{\fs14}Super important one for your next homework.
Dialogue: 0,1:11:36.15,1:11:38.92,冬青黑体简体中文,,0,0,0,,你们下次作业也许是周一布置 也许是下周三布置\N{\fs14}Your next homework might go out on Monday; might go out on next Wednesday.
Dialogue: 0,1:11:38.92,1:11:40.88,冬青黑体简体中文,,0,0,0,,我们现在还不确定\N{\fs14}I'm not quite sure yet.
Dialogue: 0,1:11:40.88,1:11:43.68,冬青黑体简体中文,,0,0,0,,反正都是一周后交\N{\fs14}But in case, it will be due a week later.
Dialogue: 0,1:11:43.68,1:11:44.65,冬青黑体简体中文,,0,0,0,,就这些了\N{\fs14}So that's it.
Dialogue: 0,1:11:44.65,1:11:47.32,冬青黑体简体中文,,0,0,0,,有问题的可以来提\N{\fs14}And if you have any questions, I'll be here.
Dialogue: 0,1:11:47.32,1:11:50.47,冬青黑体简体中文,,0,0,0,,下次再见\N{\fs14}And I'll see you next time.
Dialogue: 0,1:11:50.47,1:11:54.35,冬青黑体简体中文,,0,0,0,,更多内容 请访问我校官网stanford.edu\N{\fs14}> For more, please visit us at Stanford.edu.
